%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 1: Introducción 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%---------------------------------------------------------------------------------
\section{Sección Uno}
\label{1:sec:1}

Todo empezó con un hilo en el foro de internet ``forocoches.com'', en él hablaban de 
que la programación funcional iba a tener cada día más relevancia porque cuenta con ventajas de 
las cuales la imperativa carece.\\

A raíz de ello, me interesé por este paradigma y empecé a (e incluso terminé de) leer numerosos 
libros sobre el lenguaje y la programación funcional en general, y a crear pequeños programas en 
Haskell. Haskell es muy interesante debido a que es el lenguaje con mayor nivel de 
abstracción en el que he programado hasta hoy.\\

Haskell es idóneo para crear lenguajes de dominio específico. En otras palabras, antes de 
escribir un compilador se captura el lenguaje a compilar (el lenguaje fuente) en un 
tipo. Las expresiones de ese tipo representarán términos en el lenguaje fuente y normalmente son 
bastante similares al mismo, a pesar de ser, realmente, tipos de Haskell.\\

Luego se representa el lenguaje objetivo como otro tipo más. Finalmente, el compilador es 
realmente una función del tipo fuente al tipo objetivo y las traducciones son fáciles de escribir y 
leer. Las optimizaciones también son funciones como cualquier otra (ya que realmente en Haskell 
todo es una función, y además, currificada) que mapean del dominio del lenguaje fuente al codominio
del lenguaje objetivo.\\

Por ello los lenguajes funcionales con sintaxis ligera y un fuerte sistema de tipos se consideran 
muy adecuados para crear compiladores y muchas otras cosas cuya finalidad es la traducción.\\

Además, Haskell cuenta con mecanismos de abstracción muy fuertes que permiten escribir códigos 
escuetos que se comportan muy bien, como por ejemplo:\\

\begin{itemize}
  \item reconocimiento de patrones
  \item tipos de datos algebraicos (generalizados o no)
  \item lambdas (y por ello, mónadas)
  \item plegados de listas
\end{itemize}

A continuación se describen los mencionados constructos; el reconocimiento de patrones y los tipos de datos algebraicos se incluyen en la misma sección porque son conceptos que están muy relacionados.

%---------------------------------------------------------------------------------
\section{Reconocimiento de patrones y tipos de datos algebraicos}
\label{1:sec:2}



%---------------------------------------------------------------------------------
\section{Lambdas}
\label{1:sec:3}

Bla, bla, bla

%---------------------------------------------------------------------------------
\section{Plegados de listas}
\label{1:sec:4}

Pondremos un ejemplo real codificado por mí, un DFA hecho mediante un plegado de listas por la izquierda.\\

\begin{sourcecode}
  probarDFA :: DFA $->$ [Char] $->$ Bool\\
  probarDFA (DFA i a t) = a . foldl' t i\\
\end{sourcecode}

Un DFA se podría implementar en programación imperativa con un bucle for que fuera sobreescribiendo el estado en cada iteración, haciendo un lookup en su tabla de estados dependiendo de su estado actual y el símbolo leído.

Esto, en Haskell, se puede hacer usando la función \textbf{foldl} (aunque aquí por temas de rendimiento y uso de memoria se ha optado por \textbf{foldl'}).

Se trata de empezar con un acumulador (en este caso, el estado inicial), y nos vamos moviendo por la lista (cadena de entrada) de izquierda a derecha, haciendo un lookup...

%------------------------------------------------------------------------------
\begin{figure}[!th]
\begin{center}
\includegraphics[width=0.5\textwidth]{images/arbolbinario.eps}
\caption{Ejemplo}
\label{fig:ArbolBinario}
\end{center}
\end{figure}
%------------------------------------------------------------------------------

