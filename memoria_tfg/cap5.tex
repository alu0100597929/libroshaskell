%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 5: Conclusiones y Trabajos Futuros 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Este capítulo es obligatorio.
Toda memoria de Trabajo de Fin de Grado debe incluir unas conclusiones y unas 
líneas de trabajo futuro 

La programación funcional es un paradigma en auge ahora mismo, sobre todo por sus aplicaciones en paralelismo y matemáticas, así como por su capacidad para que los programas sean casi inmunes a ataques de fuzzing, y por dar lugar a programas menos propensos a erorres por parte del programador.

Sin embargo, el aprendizaje de la programación funcional es, sobre todo, lento, y muy relacionado con el álgebra abstracta, el lambda cálculo y la teoría de las categorías. Es el paradigma más abstracto que conozco y requiere una cabeza amueblada para tal fin, por ello lo veo más orientado (al menos a priori) a matemáticos que a ingenieros informáticos.

Los programas funcionales son muy, muy modulares, en el sentido de que hay gran cantidad de funciones definidas en ellos (de hecho en la programación funcional no se puede hacer otra cosa), y esto permite que sean poco propensos a errores, pues las funciones no comparten estado, se limitan a recibir entradas y producir salidas (esto se conoce como transparencia referencial o ``pureza''). El programador puede entonces limitarse a pensar cómo a partir de una entrada producir una salida, y esto lleva en muchos casos a generalizaciones y abstracciones bastante más potentes que las que se consiguen en otros lenguajes.

