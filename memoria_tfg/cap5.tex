%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 5: Conclusiones y Trabajos Futuros 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

La programaci\'on funcional es un paradigma en auge ahora mismo, sobre todo por sus aplicaciones en paralelismo y matem\'aticas, as\'i como por su capacidad para que los programas sean casi inmunes a ataques de fuzzing, y por dar lugar a programas menos propensos a errores por parte del programador.\\

Sin embargo, el aprendizaje de la programaci\'on funcional es, sobre todo, lento, y muy relacionado con el \'algebra abstracta, el lambda c\'alculo y la teor\'ia de las categor\'ias. Es el paradigma m\'as abstracto que conozco y requiere una cabeza amueblada para tal fin, por ello lo veo m\'as orientado (al menos a priori) a matem\'aticos que a ingenieros inform\'aticos.\\

Los programas funcionales son muy, muy modulares, en el sentido de que hay gran cantidad de funciones definidas en ellos (de hecho en la programaci\'on funcional no se puede hacer otra cosa), y esto permite que sean poco propensos a errores, pues las funciones no comparten estado, se limitan a recibir entradas y producir salidas (esto se conoce como transparencia referencial o ``pureza''). El programador puede entonces limitarse a pensar c\'omo a partir de una entrada producir una salida, y esto lleva en muchos casos a generalizaciones y abstracciones bastante m\'as potentes que las que se consiguen en otros paradigmas.\\

En el caso de los compiladores e int\'erpretes, un lenguaje como Haskell es muy potente. Los tipos de datos algebraicos nos permiten construir valores para luego aplicar reconocimiento de patrones, creando lenguajes de dominio espec\'ifico muy f\'acilmente. Esto se hace especialmente id\'oneo para interpretar lenguajes funcionales como Scheme. En este caso, contamos con m\'ultiples funciones y estructuras de datos que se comportan como las de Scheme, y nos aprovechamos de ello.\\

En cuanto al rendimiento, es muy bueno, y puede trabajar con enteros inmensamente grandes para calcular, por ejemplo, factoriales enormes. El c\'odigo es f\'acilmente adaptable y se le pueden a\~{n}adir nuevas funciones o ecuaciones a funciones ya existentes con facilidad.\\

Creo que la programaci\'on funcional es muy v\'alida para seg\'un qu\'e tareas, y no tanto para otras, por ello, los lenguajes con mayor proyecci\'on hoy en d\'ia son, al menos para m\'i, Javascript y Rust. Estos dos lenguajes son mixtos (tienen parte imperativa y funcional) y es el camino que creo que tomar\'an los lenguajes en el futuro. La programaci\'on funcional sirve para enfocar los problemas de otra manera, y abre la mente a los programadores imperativos.\\

Como l\'ineas de trabajo futuro, se podr\'ian usar las ideas del c\'odigo ya hecho para hacer un compilador de Scheme a C, usando tambi\'en Haskell u otro lenguaje funcional. Asimismo, se podr\'ia implementar el estado del programa mediante el combinador punto fijo. Tambi\'en se podr\'ian a\~{n}adir las caracter\'isticas que se proponen en el tutorial en el cual me he basado, como por ejemplo macros (preprocesar el c\'odigo y hacerle modificaciones antes de que se ejecute), o continuaciones (computaciones que se ejecutan y guardan su resultado, para aprovechar el tiempo invertido si hay que volver a usar ese resultado m\'as adelante, evitando m\'ultiples ejecuciones de la misma computaci\'on).