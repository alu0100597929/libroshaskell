%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 4 : T'itulo del Cap'itulo cuatro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

En el cap\'itulo ~\ref{chapter:tres} se describi\'o el lenguaje Scheme, dando una idea general sobre el mismo. En el presente cap\'itulo se tratar\'a de explicar el funcionamiento del programa principal del presente Trabajo Fin de Grado.

\section{Estructura general del programa}
\label{3:sec1}

En un programa escrito en Haskell, la mayor\'ia de funciones son puras, es decir, s\'olo conocen el conjunto de argumentos que reciben y s\'olo pueden actuar sobre ellos, devolviendo al final de su ejecuci\'on un valor de su tipo de retorno.\\

El concepto descrito de funci\'on pura no se corresponde con el de las funciones de lenguajes imperativos como C, C++ o Java. En los mencionados lenguajes, las funciones no tienen demasiado que ver con las funciones matem\'aticas formales. Las funciones de C, C++ o Java pueden imprimir por pantalla, interactuar con el usuario y, en definitiva, recibir informaci\'on que est\'a m\'as all\'a del \'ambito de sus par\'ametros.\\

Para superar esta dificultad se cre\'o el concepto de m\'onada. Las m\'onadas tienen fama de algo m\'as que abstracto, muy dif\'icil de entender, y estoy de acuerdo en que no son sencillas, pero las intentar\'e explicar al menos hasta donde llega mi entendimiento. Las m\'onadas, en esencia, son constructos que se realizan con lambdas estructuradas de un modo especial y con sus argumentos, y de este modo se consigue encapsular una computaci\'on o acci\'on. Como un argumento podr\'ia depender de argumentos de lambdas anteriores, se consigue, en el caso de la m\'onada IO, que las acciones se ejecuten en el orden deseado. Recordemos que Haskell, al ser un lenguaje funcional, ejecuta ``todo a la vez'', y mediante las m\'onadas, conseguimos una ejecuci\'on ordenada (entre otras cosas).\\

En el programa que se pasar\'a a describir se han usado varias m\'onadas, cada cual cumple una funci\'on distinta, que, sin m\'as dilaci\'on, pasamos a explicar.\\

El tipo \textbf{IO} es instancia de la clase de tipos \textbf{Monad}, m\'onada es un concepto, decir que un valor pertenece a la clase de tipos \textbf{\textbf{Monad}} es decir:

\begin{itemize}
  \item 1) Hay (un cierto tipo de) informaci\'on oculta adjunta a este valor.
  \item 2) La mayor\'ia de funciones no se tienen que preocupar de esa informaci\'on.
\end{itemize}

En este caso:\\

La informaci\'on extra son acciones \textbf{IO} que se ejecutar\'an usando los valores que se van pasando de una a otra; mientras que el valor b\'asico (el cual tiene informaci\'on adjunta) es void, la tupla vac\'ia o unidad, \textbf{()}.\\

IO \textbf{[String]} e \textbf{IO ()} pertenecen al mismo tipo, el de la m\'onada \textbf{IO}, pero tienen distintos tipos base. Act\'uan sobre (y se pasan unos a otros) valores de distintos tipos, \textbf{[String]} y \textbf{()}.\\

Los valores con informaci\'on oculta adjunta son llamados valores mon\'adicos.\\

Los valores mon\'adicos se suelen denominar acciones, porque la manera m\'as f\'acil de pensar en el uso de la m\'onada \textbf{IO} es pensar en una secuencia de acciones afectando al mundo exterior. Cada acci\'on de la mencionada secuencia de acciones podr\'ia actuar sobre valores b\'asicos (no mon\'adicos). Por tanto:

\begin{itemize}
  \item \textbf{m a} es una acci\'on
  \item \textbf{(a -\begin{small}\textgreater\end{small} m ())} es una funci\'on que devuelve una acci\'on que contiene la tupla vac\'ia o unidad \textbf{()}.
\end{itemize}

En los bloques do no se pueden mezclar acciones de m\'onadas diferentes.\\

Hay dos maneras de crear una acci\'on IO:

\begin{itemize}
  \item Elevar un valor ordinario en la m\'onada IO, usando la funci\'on \textbf{return}.
  \item Combinar dos acciones existentes.
\end{itemize}

Para combinar estas acciones, usamos un bloque \textbf{do}. Un bloque \textbf{do} consiste en una serie de l\'ineas (las cuales tienen que tener la misma indentaci\'on). Cada l\'inea puede tener una de estas dos formas:

\begin{itemize}
  \item nombre $<-$ acci\'on1
  \item acci\'on2
\end{itemize}

La primera forma liga el resultado de \textbf{acci\'on1} a nombre, para que est\'e disponible en las siguientes acciones. Por ejemplo, si el tipo de \textbf{acci\'on1} es \textbf{IO [String]}, entonces el nombre estar\'a ligado en todas las acciones y lo podremos usar en acciones posteriores, y esto se consigue mediante el operador bind ($>>=$).

En la segunda opci\'on, simplemente ejecutamos la acci\'on (por ejemplo, imprimir algo por pantalla) pero no ligamos nada a ning\'un nombre, ya que consideramos que no es necesario. Esto se consigue mediante el operador ($>>$).

Parsec (en realidad, \textbf{genParser}) es otro ejemplo de m\'onada: en este caso, la informaci\'on extra que se encuentra oculta es toda aquella relativa a la posici\'on en la cadena de entrada, registro de backtracking, conjuntos first y follow...etc\'etera.\\

La funci\'on \textbf{parse} devuelve un \textbf{Either}, que tendremos que manejar seg\'un construya un \textbf{Left} (ParseError) o \textbf{Right} (valor correcto).\\

\textbf{readExpr} recibe una \textbf{String} (la cadena de entrada) y devuelve otra \textbf{String} con informaci\'on de lo que haya parseado.\\

\textbf{readExpr} utiliza la funci\'on parse, que devuelve un \textbf{Either}, que \textbf{readExpr} maneja seg\'un construya un valor de tipo \textbf{Left} (error) o un valor de tipo \textbf{Right} (valor correcto).\\

Luego se trata de ir parseando los diferentes tokens de Scheme y luego construir, mediante un constructor de valor para el tipo \textbf{LispVal}, un valor determinado.\\

Para ello se aplican parsers de Parsec y se extrae la informaci\'on oculta de aquello que han parseado mediante el constructo \textbf{\begin{small}\textless\end{small}-}, o se usa (\textbf{liftM} funci\'on valor\_mon\'adico). Esto quiz\'as requiera una explicaci\'on adicional:

\begin{itemize}
  \item \textbf{\begin{small}\textless\end{small}-} permite ligar a un nombre la informaci\'on oculta en un valor mon\'adico.
  \item (\textbf{liftM} funci\'on valor\_mon\'adico) ``eleva'' (de ah\'i que su nombre empiece por lift) una funci\'on que act\'ua sobre tipos no mon\'adicos a otra que act\'ua sobre los valores que la mon\'ada tiene dentro.
\end{itemize}

Parsers recursivos:\\

En un lenguaje funcional la recursividad es uno de los m\'etodos m\'as interesantes. En un lenguaje como Scheme y muchos otros, encontramos estructuras de datos que pueden contener a otras, por ejemplo, una lista puede contener:

\begin{itemize}
  \item otras listas (sean normales o de tipo dotted)
  \item cualquier otra expresi\'on.
\end{itemize}

Por tanto, en el int\'erprete se llama recursivamente al parser principal, \textbf{parseExpr :: Parser LispVal}, con el objetivo de parsear lo que haya dentro de cada expresi\'on.\\

Por ejemplo, en \textbf{parseList} y \textbf{parseDottedList} se usan, respectivamente:

\begin{itemize}
  \item sepBy parseExpr spaces
  \item endBy parseExpr spaces
\end{itemize}

Los cuales van a devolver una [\textbf{LispVal}], justo el argumento que necesita el constructor de tipo \textbf{List} y el primero que necesita \textbf{DottedList}.\\

Por tanto, vemos que mediante el uso de \textbf{sepBy} y \textbf{endBy} estamos haciendo llamadas recursivas a \textbf{parseExpr} y por ello nuestro parser es capaz de lidiar con estructuras anidadas de manera casi gratuita.\\

Lo primero de todo es hacer \textbf{LispVal} instancia de \textbf{Show} para poder imprimir por pantalla los valores de tipo \textbf{LispVal}.\\

Para ello se crea la funci\'on \textbf{showVal :: LispVal -{\begin{small}\textgreater\end{small} String}} y se iguala a \textbf{show} (\textbf{instance Show \textbf{LispVal} where show = showVal}). Para los dos tipos de listas, \textbf{List} y \textbf{DottedList}, se usa la funci\'on \textbf{unwordsList}:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
unwordsList :: [LispVal] -> String
unwordsList = unwords . map showVal
\end{lstlisting}
\end{small}
\end{minipage}

Ahora empezamos con el evaluador propiamente dicho:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
eval :: LispVal -> LispVal
eval val@(String _) = val
eval val@(Number _) = val
eval val@(Bool _) = val
eval (List [Atom "quote", val]) = val
\end{lstlisting}
\end{small}
\end{minipage}

\textbf{LispVal} se puede ver como una expresi\'on, y cambiaremos \textbf{LispVal} para que devuelva una expresi\'on en vez de su valor de cadena de car\'acteres.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
readExpr :: String -> LispVal
readExpr input = case parse parseExpr "lisp" input of
    Left err -> String $ "No match: " ++ show err
    Right val -> val
\end{lstlisting}
\end{small}
\end{minipage}

Cambiamos el c\'odigo de la funci\'on \textbf{main} para que eval\'ue las expresiones en vez de s\'olo imprimirlas por pantalla:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
main :: IO ()
main = getArgs >>= print . eval . readExpr . head
\end{lstlisting}
\end{small}
\end{minipage}

A\~nadimos a la funci\'on eval una ecuaci\'on que nos permitir\'a aplicar funciones a sus argumentos (para aplicar funciones se debe poner una lista cuyo primer elemento es el nombre de la funci\'on y luego los dem\'as elementos ser\'an los argumentos de dicha funci\'on):\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
eval (List (Atom func : args)) = apply func $ map eval args
\end{lstlisting}
\end{small}
\end{minipage}

Como vemos, tenemos hecha una ecuaci\'on que es recursiva, mapea eval sobre los argumentos, con lo cual ya tenemos resuelto el problema de evaluar listas anidadas de manera ``gratuita''.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
apply :: String -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
\end{lstlisting}
\end{small}
\end{minipage}

La funci\'on \textbf{maybe} recibe un valor por defecto, una funci\'on, y un valor de tipo \textbf{Maybe}. Si el valor de tipo \textbf{Maybe} es \textbf{Nothing}, la funci\'on devuelve el valor por defecto. Si no, aplica la funci\'on al valor dentro del \textbf{Just} y devuelve el resultado.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
primitives :: [(String, [LispVal] -> LispVal)]
primitives = [("+", numericBinop (+)),
              ("-", numericBinop (-)),
              ("*", numericBinop (*)),
              ("/", numericBinop div),
              ("mod", numericBinop mod),
              ("quotient", numericBinop quot),
              ("remainder", numericBinop rem)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> LispVal
numericBinop op params = Number $ foldl1 op $ map unpackNum params
 
unpackNum :: LispVal -> Integer
unpackNum (Number n) = n
unpackNum (String n) = let parsed = reads n :: [(Integer, String)] in 
                           if null parsed 
                              then 0
                              else fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum _ = 0
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Crearemos una m\'onada llamada \textbf{ThrowsError}, que en realidad se comporta como la m\'onada \textbf{Either}:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
type ThrowsError = Either LispError
\end{lstlisting}
\end{small}
\end{minipage}

la l\'inea de arriba est\'a currificada, se podr\'ia escribir as\'i tambi\'en:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
type ThrowsError b = Either LispError b
\end{lstlisting}
\end{small}
\end{minipage}

\textbf{ThrowsError} es, por tanto, una m\'onada que puede contener \textbf{LispError} (en el caso de \textbf{Left}) o un tipo b, que en nuestro programa es \textbf{LispVal} (en el caso de \textbf{Right}). Por tanto, cuando accedemos a su interior, encontraremos un \textbf{LispError} o un \textbf{LispVal}. Es decir, estamos definiendo un tipo que puede ser del tipo \textbf{b}, o bien dar error.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
readExpr :: String -> ThrowsError LispVal
eval :: LispVal -> ThrowsError LispVal
showVal :: LispVal -> String
\end{lstlisting}
\end{small}
\end{minipage}

\textbf{Either} es una m\'onada en la cual \textbf{bind ($>>=$)} para su ejecuci\'on cuando encuentra un \textbf{Left}, devolviendo ese \textbf{Left} y ahorrando mucho tiempo de computaci\'on.\\

La m\'onada \textbf{Either} tambi\'en provee otras dos funciones a parte de las mon\'adicas est\'andar:\\

\textbf{throwsError} recibe un valor de tipo \textbf{Error} y lo eleva al constructor \textbf{Left} (error) de un \textbf{Either}.\\

Se usa \textbf{throwsError} porque en realidad, no existe el constructor de valor \textbf{LispError}, sino que es un constructor de tipo. Por ello, mediante \textbf{throwsError}, creamos un \textbf{Left} (el \textbf{LispError} concreto que sea), lo cual es un resultado de tipo \textbf{ThrowsError} \textbf{LispVal}, el tipo retorno de \textbf{readExpr}.\\

\textbf{catchError}: recibe un valor \textbf{Either} (una acci\'on) y si es \textbf{Right}, lo devuelve, si es \textbf{Left}, le aplica la funci\'on que recibe (en este caso est\'a hardcoded, y lo que hace es pasar del \textbf{Left} a un valor normal de \textbf{LispVal}). El sentido de todo esto es que
el \textbf{Either} resultado siempre tenga un valor \textbf{Right}:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
trapError action = catchError action (return . show)
\end{lstlisting}
\end{small}
\end{minipage}

De este modo lo que hacemos es transformar los errores (\textbf{Left}) en su representaci\'on como valor de tripo \textbf{String} en el contexto de la m\'onada \textbf{Either}.\\

Ahora que tenemos asegurado que todos los valores van a ser \textbf{Right}, hagamos un accessor
efectivo:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
extractValue :: ThrowsError a -> a
extractValue Right val) = val
\end{lstlisting}
\end{small}
\end{minipage}

La funci\'on parse devuelve un \textbf{Either}, que tendremos que manejar seg\'un construya un \textbf{Left} (ParseError) o \textbf{Right} (valor correcto).\\

Ahora \textbf{eval} va a devolver un valor mon\'adico, con lo cual, en vez de \textbf{map} debemos usar \textbf{mapM}, y usar \textbf{return} para encapsular en valores mon\'adicos los resultados de \textbf{eval}.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
mapM :: Monad m => (a -> m b) -> [a] -> m [b]:
\end{lstlisting}
\end{small}
\end{minipage}

\textbf{mapM mf xs} recibe una funci\'on mon\'adica (con tipo \textbf{Monad m => (a -> m b)}) y la aplica a cada elemento en la lista \textbf{xs}; el resultado es una lista (con elementos del tipo \textbf{b}, en este caso) dentro de una m\'onada. Por tanto \textbf{mapM eval args} da como resultado [\textbf{LispVal}].\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
eval :: LispVal -> ThrowsError LispVal
eval val@(String _) = return val
eval val@(Number _) = return val
eval val@(Bool _) = return val
eval (List [Atom "quote", val]) = return val
eval (List (Atom func : args)) = mapM eval args >>= apply func
eval badForm = throwError $ BadSpecialForm "Unrecognized special form" badForm

apply :: String -> [LispVal] -> ThrowsError LispVal
apply func args = maybe (throwError $ NotFunction "Unrecognized primitive function args" func)
                        ($ args)
                        (lookup func primitives)

primitives :: [(String, [LispVal] -> ThrowsError LispVal)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> ThrowsError LispVal
numericBinop op           []  = throwError $ NumArgs 2 []
numericBinop op singleVal@[_] = throwError $ NumArgs 2 singleVal
numericBinop op params        = mapM unpackNum params >>= return . Number . foldl1 op

unpackNum :: LispVal -> ThrowsError Integer
unpackNum (Number n) = return n
unpackNum (String n) = let parsed = reads n in 
                           if null parsed 
                             then throwError $ TypeMismatch "number" $ String n
                             else return $ fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum notNum     = throwError $ TypeMismatch "number" notNum
\end{lstlisting}
\end{tiny}
\end{minipage}

Aqu\'i lo m\'as complicado es saber el tipo de \textbf{evaled}, as\'i que vayamos por partes:

\begin{itemize}

\item 1) $readExpr (args !! 0) >>= eval$: readExpr da un \textbf{ThrowsError LispVal}, luego bind lo que hace es pasar el \textbf{LispVal} a eval, y acaba dando otro \textbf{ThrowsError LispVal}.

\item 2) \textbf{liftM} show sobre la m\'onada \textbf{ThrowsError LispVal} da una ThrowsError String.

\item 3) hacer return sobre una ThrowsError String nos devuelve un (\textbf{IO (Either ThrowsError String)}, y esto se hace para que al operar con el constructo \textbf{\<\-} sigamos teniendo el \textbf{Either ThrowsError String}, que es lo que recibe (\textbf{trapError}).

\textbf{Recuerda:}, si estamos trabajando en un do de una m\'onada tipo \textbf{IO}, el \textbf{return} va a envolver el dato en una m\'onada \textbf{IO}, y esto es v\'alido para cualquier m\'onada.

\item 4) trapError nos devuelve un \textbf{Either} del tipo \textbf{Either String}, porque recordemos, \textbf{Left} era \textbf{LispError}, \textbf{Right} era \textbf{String}, y \textbf{catchError} siempre devuelve \textbf{Right}.

\item 5) \textbf{extractValue} nos devuelve un valor de tipo \textbf{String}.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
main :: IO ()
main = do
     args <- getArgs
     evaled <- return $ liftM show $ readExpr (args !! 0) >>= eval
     putStrLn $ extractValue $ trapError evaled
\end{lstlisting}
\end{small}
\end{minipage}

Todas las funciones cuyo primer argumento es \textbf{LispVal} deben usar pattern matching para saber qu\'e constructor de valor se ha usado para crear el mencionado \textbf{LispVal}.\\

La funci\'on \textbf{car} de Scheme devuelve el primer elemento de una lista que se pasa como argumento. \textbf{cdr} de Scheme es justo lo contrario, devuelve el resto de la lista.\\

\textbf{cons} es el operador \textbf{(:)} de Haskell, es decir, el que sirve para concatenar un elemento a una lista del tipo de ese elemento.\\

Ahora definimos un cuantificador existencial (s\'i, aunque se llame \textbf{forall}, no es universal). Esto lo que hace es crear un constructor de valor \textbf{AnyUnpacker} que recibe funciones de \textbf{Lispval} a \textbf{ThrowsError a}, para todo tipo a que sea instancia de la clase de tipos \textbf{Eq}:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
data Unpacker = forall a. Eq a => AnyUnpacker (LispVal -> ThrowsError a)

unpackEquals :: LispVal} -> LispVal -> Unpacker -> ThrowsError Bool
unpackEquals arg1 arg2 (AnyUnpacker unpacker) = 
             do unpacked1 <- unpacker arg1
                unpacked2 <- unpacker arg2
                return $ unpacked1 == unpacked2
        catchError (const $ return False)
\end{lstlisting}
\end{small}
\end{minipage}

Aqu\'i lo que hacemos es crear un bloque \textbf{do} en el cual desempaquetamos los dos argumentos \textbf{arg1} y \textbf{arg2}, lig\'andolos a las variables \textbf{unpacked1} y \textbf{unpacked2}. Luego comprobamos su igualdad (ser\'an casi seguro \textbf{LispVal}s) y Los volvemos a meter en la m\'onada \textbf{ThrowsError}.\\

Ahora entra en juego \textbf{catchError}, que, recordemos, lo que hac\'ia es recibir un \textbf{Either} y si es \textbf{Right}, devolver ese mismo \textbf{Either}, si es \textbf{Left}, aplicarle la funci\'on de la derecha.\\

Veamos en qu\'e consiste \textbf{cons} para saber por qu\'e se ha usado.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
const            :: a -> b -> a
const x _        =  x
\end{lstlisting}
\end{small}
\end{minipage}

Veamos los tipos de cada una de las partes para entenderlo mejor:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
Prelude Control.Monad.Except> :t (const $ return False)
(const $ return False) :: Monad m => b -> m Bool
Prelude Control.Monad.Except> :t (return False)
(return False) :: Monad m => m Bool
\end{lstlisting}
\end{small}
\end{minipage}

Luego lo que est\'a haciendo \textbf{const} es permitir una currificaci\'on que, da igual lo que reciba esa funci\'on (en este caso recibe un \textbf{Left} conteniendo el error), devolver\'a siempre lo primero que recibi\'o, en este caso el resultado de \textbf{return False}, que no es otra cosa que un \textbf{ThrowsError Bool}.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
equal :: [LispVal] -> ThrowsError LispVal
equal [arg1, arg2] = do
      primitiveEquals <- liftM or $ mapM (unpackEquals arg1 arg2) 
                         [AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]
      eqvEquals <- eqv [arg1, arg2]
      return $ Bool $ (primitiveEquals || let (Bool x) = eqvEquals in x)
equal badArgList = throwError $ NumArgs 2 badArgList
\end{lstlisting}
\end{small}
\end{minipage}

El tipo de \textbf{unpackEquals arg1 arg2} es \textbf{Unpacker -> ThrowsError Bool}, por tanto, \textbf{mapM (unpackEquals arg1 arg2)} sobre la lista \textbf{[AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]} dar\'a una m\'onada \textbf{ThrowsError} conteniendo una lista de Bool, es decir, \textbf{ThrowsError [Bool]}. A dicha lista le aplicaremos la funci\'on or mediante \textbf{liftM}.\\

Para lidiar con las cl\'ausulas \textbf{else} se ha realizado un ``hack'', cada vez que \textbf{eval} se encuentra un \textbf{else}, devuelve un \textbf{Bool True} para que siempre se ejecute esa expresi\'on.\\