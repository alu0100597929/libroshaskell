%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 4 : T'itulo del Cap'itulo cuatro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

En el cap\'itulo ~\ref{chapter:tres} se describi\'o el lenguaje Scheme, dando una idea general sobre el mismo. En el presente cap\'itulo se tratar\'a de explicar el funcionamiento del programa principal del presente Trabajo Fin de Grado.

\section{Estructura general del programa}
\label{3:sec1}

En un programa escrito en Haskell, la mayor\'ia de funciones son puras, es decir, s\'olo conocen el conjunto de argumentos que reciben y s\'olo pueden actuar sobre ellos, devolviendo al final de su ejecuci\'on un valor de su tipo de retorno.\\

El concepto descrito de funci\'on pura no se corresponde con el de las funciones de lenguajes imperativos como C, C++ o Java. En los mencionados lenguajes, las funciones no tienen demasiado que ver con las funciones matem\'aticas formales. Las funciones de C, C++ o Java pueden imprimir por pantalla, interactuar con el usuario y, en definitiva, recibir informaci\'on que est\'a m\'as all\'a del \'ambito de sus par\'ametros.\\

Para superar esta dificultad se cre\'o el concepto de m\'onada. Las m\'onadas tienen fama de algo m\'as que abstracto, muy dif\'icil de entender, y estoy de acuerdo en que no son sencillas, pero las intentar\'e explicar al menos hasta donde llega mi entendimiento. Las m\'onadas, en esencia, son constructos que se realizan con lambdas estructuradas de un modo especial y con sus argumentos, y de este modo se consigue encapsular una computaci\'on o acci\'on. Como un argumento podr\'ia depender de argumentos de lambdas anteriores, se consigue, en el caso de la m\'onada IO, que las acciones se ejecuten en el orden deseado. Recordemos que Haskell, al ser un lenguaje funcional, ejecuta ``todo a la vez'', y mediante las m\'onadas, conseguimos una ejecuci\'on ordenada (entre otras cosas).\\

En el programa que se pasar\'a a describir se han usado varias m\'onadas, cada cual cumple una funci\'on distinta, que, sin m\'as dilaci\'on, pasamos a explicar.\\

El tipo \textbf{IO} es instancia de la clase de tipos \textbf{Monad}, m\'onada es un concepto, decir que un valor pertenece a la clase de tipos \textbf{\textbf{Monad}} es decir:

\begin{itemize}
  \item 1) Hay (un cierto tipo de) informaci\'on oculta adjunta a este valor.
  \item 2) La mayor\'ia de funciones no se tienen que preocupar de esa informaci\'on.
\end{itemize}

En este caso:\\

La informaci\'on extra son acciones \textbf{IO} que se ejecutar\'an usando los valores que se van pasando de una a otra; mientras que el valor b\'asico (el cual tiene informaci\'on adjunta) es void, la tupla vac\'ia o unidad, \textbf{()}.\\

IO \textbf{[String]} e \textbf{IO ()} pertenecen al mismo tipo, el de la m\'onada \textbf{IO}, pero tienen distintos tipos base. Act\'uan sobre (y se pasan unos a otros) valores de distintos tipos, \textbf{[String]} y \textbf{()}.\\

Los valores con informaci\'on oculta adjunta son llamados valores mon\'adicos.\\

Los valores mon\'adicos se suelen denominar acciones, porque la manera m\'as f\'acil de pensar en el uso de la m\'onada \textbf{IO} es pensar en una secuencia de acciones afectando al mundo exterior. Cada acci\'on de la mencionada secuencia de acciones podr\'ia actuar sobre valores b\'asicos (no mon\'adicos). Por tanto:

\begin{itemize}
  \item \textbf{m a} es una acci\'on
  \item \textbf{(a -\begin{footnotesize}\textgreater\end{footnotesize} m ())} es una funci\'on que devuelve una acci\'on que contiene la tupla vac\'ia o unidad \textbf{()}.
\end{itemize}

En los bloques do no se pueden mezclar acciones de m\'onadas diferentes.\\

Hay dos maneras de crear una acci\'on IO:\\

\begin{itemize}
  \item Elevar un valor ordinario en la m\'onada IO, usando la funci\'on \textbf{return}.
  \item Combinar dos acciones existentes.
\end{itemize}

Para combinar estas acciones, usamos un bloque \textbf{do}. Un bloque \textbf{do} consiste en una serie de l\'ineas (las cuales tienen que tener la misma indentaci\'on). Cada l\'inea puede tener una de estas dos formas:

\begin{itemize}
  \item nombre $<-$ acci\'on1
  \item acci\'on2
\end{itemize}

La primera forma liga el resultado de \textbf{acci\'on1} a nombre, para que est\'e disponible en las siguientes acciones. Por ejemplo, si el tipo de \textbf{acci\'on1} es \textbf{IO [String]}, entonces el nombre estar\'a ligado en todas las acciones y lo podremos usar en acciones posteriores, y esto se consigue mediante el operador bind ($>>=$).\\

En la segunda opci\'on, simplemente ejecutamos la acci\'on (por ejemplo, imprimir algo por pantalla) pero no ligamos nada a ning\'un nombre, ya que consideramos que no es necesario. Esto se consigue mediante el operador ($>>$).\\

Parsec (en realidad, \textbf{genParser}) es otro ejemplo de m\'onada: en este caso, la informaci\'on extra que se encuentra oculta es toda aquella relativa a la posici\'on en la cadena de entrada, registro de backtracking, conjuntos first y follow...etc\'etera.\\

La funci\'on \textbf{parse} devuelve un \textbf{Either}, que tendremos que manejar seg\'un construya un \textbf{Left} (ParseError) o \textbf{Right} (valor correcto).\\

\textbf{readExpr} recibe una \textbf{String} (la cadena de entrada) y devuelve otra \textbf{String} con informaci\'on de lo que haya parseado.\\

\textbf{readExpr} utiliza la funci\'on parse, que devuelve un \textbf{Either}, que \textbf{readExpr} maneja seg\'un construya un valor de tipo \textbf{Left} (error) o un valor de tipo \textbf{Right} (valor correcto).\\

Luego se trata de ir parseando los diferentes tokens de Scheme y luego construir, mediante un constructor de valor para el tipo \textbf{LispVal}, un valor determinado.\\

Para ello se aplican parsers de Parsec y se extrae la informaci\'on oculta de aquello que han parseado mediante el constructo \textbf{\begin{footnotesize}\textless\end{footnotesize}-}, o se usa (\textbf{liftM} funci\'on valor\_mon\'adico). Esto quiz\'as requiera una explicaci\'on adicional:

\begin{itemize}
  \item \textbf{\begin{footnotesize}\textless\end{footnotesize}-} permite ligar a un nombre la informaci\'on oculta en un valor mon\'adico.
  \item (\textbf{liftM} funci\'on valor\_mon\'adico) ``eleva'' (de ah\'i que su nombre empiece por lift) una funci\'on que act\'ua sobre tipos no mon\'adicos a otra que act\'ua sobre los valores que la mon\'ada tiene dentro.
\end{itemize}

Parsers recursivos:\\

En un lenguaje funcional la recursividad es uno de los m\'etodos m\'as interesantes. En un lenguaje como Scheme y muchos otros, encontramos estructuras de datos que pueden contener a otras, por ejemplo, una lista puede contener:

\begin{itemize}
  \item otras listas (sean normales o de tipo dotted)
  \item cualquier otra expresi\'on.
\end{itemize}

Por tanto, en el int\'erprete se llama recursivamente al parser principal, \textbf{parseExpr :: Parser LispVal}, con el objetivo de parsear lo que haya dentro de cada expresi\'on.\\

Por ejemplo, en \textbf{parseList} y \textbf{parseDottedList} se usan, respectivamente:

\begin{itemize}
  \item sepBy parseExpr spaces
  \item endBy parseExpr spaces
\end{itemize}

Los cuales van a devolver una [\textbf{LispVal}], justo el argumento que necesita el constructor de tipo \textbf{List} y el primero que necesita \textbf{DottedList}.\\

Por tanto, vemos que mediante el uso de \textbf{sepBy} y \textbf{endBy} estamos haciendo llamadas recursivas a \textbf{parseExpr} y por ello nuestro parser es capaz de lidiar con estructuras anidadas de manera casi gratuita.\\

Lo primero de todo es hacer \textbf{LispVal} instancia de \textbf{Show} para poder imprimir por pantalla los valores de tipo \textbf{LispVal}.\\

Para ello se crea la funci\'on \textbf{showVal :: LispVal -{\begin{footnotesize}\textgreater\end{footnotesize} String}} y se iguala a \textbf{show} (\textbf{instance Show \textbf{LispVal} where show = showVal}). Para los dos tipos de listas, \textbf{List} y \textbf{DottedList}, se usa la funci\'on \textbf{unwordsList}:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
unwordsList :: [LispVal] -> String
unwordsList = unwords . map showVal
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Ahora empezamos con el evaluador propiamente dicho:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
eval :: LispVal -> LispVal
eval val@(String _) = val
eval val@(Number _) = val
eval val@(Bool _) = val
eval (List [Atom "quote", val]) = val
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{LispVal} se puede ver como una expresi\'on, y cambiaremos \textbf{LispVal} para que devuelva una expresi\'on en vez de su valor de cadena de car\'acteres.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
readExpr :: String -> LispVal
readExpr input = case parse parseExpr "lisp" input of
    Left err -> String $ "No match: " ++ show err
    Right val -> val
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Cambiamos el c\'odigo de la funci\'on \textbf{main} para que eval\'ue las expresiones en vez de s\'olo imprimirlas por pantalla:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
main :: IO ()
main = getArgs >>= print . eval . readExpr . head
\end{lstlisting}
\end{footnotesize}
\end{minipage}

A\~nadimos a la funci\'on eval una ecuaci\'on que nos permitir\'a aplicar funciones a sus argumentos (para aplicar funciones se debe poner una lista cuyo primer elemento es el nombre de la funci\'on y luego los dem\'as elementos ser\'an los argumentos de dicha funci\'on):\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
eval (List (Atom func : args)) = apply func $ map eval args
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Como vemos, tenemos hecha una ecuaci\'on que es recursiva, mapea eval sobre los argumentos, con lo cual ya tenemos resuelto el problema de evaluar listas anidadas de manera ``gratuita''.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
apply :: String -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
\end{lstlisting}
\end{footnotesize}
\end{minipage}

La funci\'on \textbf{maybe} recibe un valor por defecto, una funci\'on, y un valor de tipo \textbf{Maybe}. Si el valor de tipo \textbf{Maybe} es \textbf{Nothing}, la funci\'on devuelve el valor por defecto. Si no, aplica la funci\'on al valor dentro del \textbf{Just} y devuelve el resultado.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
primitives :: [(String, [LispVal] -> LispVal)]
primitives = [("+", numericBinop (+)),
              ("-", numericBinop (-)),
              ("*", numericBinop (*)),
              ("/", numericBinop div),
              ("mod", numericBinop mod),
              ("quotient", numericBinop quot),
              ("remainder", numericBinop rem)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> LispVal
numericBinop op params = Number $ foldl1 op $ map unpackNum params
 
unpackNum :: LispVal -> Integer
unpackNum (Number n) = n
unpackNum (String n) = let parsed = reads n :: [(Integer, String)] in 
                           if null parsed 
                              then 0
                              else fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum _ = 0
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Aqu\'i vemos la funci\'on \textbf{primitives}, que devuelve una lista de pares (string, funci\'on), estableciendo una correspondencia entre funciones de Scheme y Haskell. En \textbf{numericBinop} tenemos una funci\'on que recibe:

\begin{itemize}
  \item una funci\'on binaria $\mathbb{Z}^2 \rightarrow \mathbb{Z}$
  \item una lista de \textbf{LispVal}
\end{itemize}

Lo que hace es primeramente desempaquetar los n\'umeros, es decir, pasarlos al tipo \textbf{Integer}. Despu\'es les aplica un plegado a la izquierda, es decir, va haciendo la operaci\'on binaria con los enteros de la lista, dos a dos (asonciando a izquierdas), y va acumulando el resultado para usarlo con el siguiente entero de la lista. Esto nos permite que operaciones no conmutativas como la resta den el resultado correcto de manera casi gratuita.\\

Manejo de errores:\\

En primera instancia crearemos un tipo de dato algebraico que generalice los errores mediante un constructor de tipos, y los concretice mediante constructores de valor:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
data LispError = NumArgs Integer [LispVal]
               | TypeMismatch String LispVal
               | Parser ParseError
               | BadSpecialForm String LispVal
               | NotFunction String String
               | UnboundVar String String
               | Default String
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Luego, crearemos una m\'onada llamada \textbf{ThrowsError}, que en realidad se comporta como la m\'onada \textbf{Either}:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
type ThrowsError = Either LispError
\end{lstlisting}
\end{footnotesize}
\end{minipage}

la l\'inea de arriba est\'a currificada, se podr\'ia escribir as\'i tambi\'en:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
type ThrowsError b = Either LispError b
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{ThrowsError} es, por tanto, una m\'onada que puede contener \textbf{LispError} (en el caso de \textbf{Left}) o un tipo b, que en nuestro programa es \textbf{LispVal} (en el caso de \textbf{Right}). Por tanto, cuando accedemos a su interior, encontraremos un \textbf{LispError} o un \textbf{LispVal}. Es decir, estamos definiendo un tipo que puede ser del tipo \textbf{b}, o bien dar error. Ahora ya nuestro int\'erprete no trabajar\'a directamente con \textbf{LispVal}, sino con \textbf{ThrowsError LispVal}. El sentido de todo esto es poder crear valores que describan el error que ha ocurrido, para luego imprimir por pantalla una explicaci\'on detallada del mismo. Ahora todas las funciones que puedan dar errores devolver\'an un \textbf{ThrowsError LispVal}, y tendremos que crear ecuaciones que capturen esos errores y construyan un \textbf{LispError} apropiado para posteriormente informar al usuario.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
readExpr :: String -> ThrowsError LispVal
eval :: LispVal -> ThrowsError LispVal
showVal :: LispVal -> String
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{Either} es una m\'onada en la cual \textbf{bind ($>>=$)} para su ejecuci\'on cuando encuentra un \textbf{Left}, devolviendo ese \textbf{Left} y ahorrando mucho tiempo de computaci\'on.\\

La m\'onada \textbf{Either} tambi\'en provee otras dos funciones a parte de las mon\'adicas est\'andar:\\

\textbf{throwsError} recibe un valor de tipo \textbf{Error} y lo eleva al constructor \textbf{Left} (error) de un \textbf{Either}.\\

Se usa \textbf{throwsError} porque en realidad, no existe el constructor de valor \textbf{LispError}, sino que es un constructor de tipo. Por ello, mediante \textbf{throwsError}, creamos un \textbf{Left} (el \textbf{LispError} concreto que sea), lo cual es un resultado de tipo \textbf{ThrowsError} \textbf{LispVal}, el tipo retorno de \textbf{readExpr}.\\

\textbf{catchError}: recibe un valor \textbf{Either} (una acci\'on) y una funci\'on. Si el valor \textbf{Either} es \textbf{Right}, lo devuelve, si es \textbf{Left}, le aplica la funci\'on que recibe (en este caso est\'a hardcoded, y lo que hace es pasar del \textbf{Left} a un valor normal de \textbf{LispVal}). El sentido de todo esto es que el \textbf{Either} resultado siempre tenga un valor \textbf{Right}:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
trapError action = catchError action (return . show)
\end{lstlisting}
\end{footnotesize}
\end{minipage}

De este modo lo que hacemos es transformar los errores (\textbf{Left}) en su representaci\'on como valor de tripo \textbf{String} en el contexto de la m\'onada \textbf{Either}.\\

Ahora que tenemos asegurado que todos los valores van a ser \textbf{Right}, hagamos un accessor
efectivo:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
extractValue :: ThrowsError a -> a
extractValue Right val) = val
\end{lstlisting}
\end{footnotesize}
\end{minipage}

La funci\'on \textbf{parse} devuelve un \textbf{Either}, que tendremos que manejar seg\'un construya un \textbf{Left} (ParseError) o \textbf{Right} (valor correcto).\\

Ahora \textbf{eval} va a devolver un valor mon\'adico, con lo cual, en vez de \textbf{map} debemos usar \textbf{mapM}, y usar \textbf{return} para encapsular en valores mon\'adicos los resultados de \textbf{eval}.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
mapM :: Monad m => (a -> m b) -> [a] -> m [b]:
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{mapM mf xs} recibe una funci\'on mon\'adica (con tipo \textbf{Monad m $=\!>$ (a $-\!>$ m b)}) y la aplica a cada elemento en la lista \textbf{xs}; el resultado es una lista (con elementos del tipo \textbf{b}, en este caso) dentro de una m\'onada. Por tanto \textbf{mapM eval args} da como resultado un valor de tipo \textbf{ThrowsError [Integer]}.\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
eval :: LispVal -> ThrowsError LispVal
eval val@(String _) = return val
eval val@(Number _) = return val
eval val@(Bool _) = return val
eval (List [Atom "quote", val]) = return val
eval (List (Atom func : args)) = mapM eval args >>= apply func
eval badForm = throwError $ BadSpecialForm "Unrecognized special form" badForm

apply :: String -> [LispVal] -> ThrowsError LispVal
apply func args = maybe (throwError $ NotFunction "Unrecognized primitive function args" func)
                        ($ args)
                        (lookup func primitives)

primitives :: [(String, [LispVal] -> ThrowsError LispVal)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> ThrowsError LispVal
numericBinop op           []  = throwError $ NumArgs 2 []
numericBinop op singleVal@[_] = throwError $ NumArgs 2 singleVal
numericBinop op params        = mapM unpackNum params >>= return . Number . foldl1 op

unpackNum :: LispVal -> ThrowsError Integer
unpackNum (Number n) = return n
unpackNum (String n) = let parsed = reads n in 
                           if null parsed 
                             then throwError $ TypeMismatch "number" $ String n
                             else return $ fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum notNum     = throwError $ TypeMismatch "number" notNum
\end{lstlisting}
\end{tiny}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
main :: IO ()
main = do
  args <- getArgs
  evaled <- return $ liftM show $ readExpr (args !! 0) >>= eval
  putStrLn $ extractValue $ trapError evaled
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Aqu\'i lo m\'as complicado es saber el tipo de \textbf{evaled}:

\begin{itemize}

\item 1) $readExpr (args !! 0) >>= eval$: readExpr da un \textbf{ThrowsError LispVal}, luego bind lo que hace es pasar el \textbf{LispVal} a eval, y acaba dando otro \textbf{ThrowsError LispVal}.

\item 2) \textbf{liftM show} sobre la m\'onada \textbf{ThrowsError LispVal} da una \textbf{ThrowsError String}.

\item 3) hacer \textbf{return} sobre una \textbf{ThrowsError String} nos devuelve un (\textbf{IO (Either ThrowsError String)}, y esto se hace para que al operar con el constructo \textbf{\<\-} sigamos teniendo el \textbf{ThrowsError String}, que es lo que recibe (\textbf{trapError}).

\textbf{Recuerda:}, si estamos trabajando en un do de una m\'onada tipo \textbf{IO}, el \textbf{return} va a envolver el dato en una m\'onada \textbf{IO}, y esto es v\'alido para cualquier m\'onada.

\item 4) \textbf{trapError} nos devuelve un \textbf{Either} del tipo \textbf{Either String}, porque recordemos, \textbf{Left} era \textbf{LispError}, \textbf{Right} era \textbf{String}, y \textbf{catchError} siempre devuelve \textbf{Right}.

\item 5) \textbf{extractValue} nos devuelve un valor de tipo \textbf{String}.
\end{itemize}

Todas las funciones cuyo primer argumento es \textbf{LispVal} deben usar pattern matching para saber qu\'e constructor de valor se ha usado para crear el mencionado \textbf{LispVal}.\\

Evaluaci\'on, parte 2\\

\textbf{boolBinop} es una funci\'on definida para ser currificada, y por ello es muy vers\'atil:\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
boolBinop :: (LispVal -> ThrowsError a) -> (a -> a -> Bool) -> [LispVal] -> ThrowsError LispVal
boolBinop unpacker op args = if length args /= 2 
                             then throwError $ NumArgs 2 args
                             else do left <- unpacker $ args !! 0
                                      right <- unpacker $ args !! 1
                                      return $ Bool $ left `op` right
\end{lstlisting}
\end{tiny}
\end{minipage}

Gracias a ella podemos usar una funci\'on arbitraria que pase de \textbf{LispVal} a \textbf{ThrowsError a} y con ello crear una plantilla para una operaci\'on binaria entre los tipos que queramos:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
numBoolBinop  = boolBinop unpackNum
strBoolBinop  = boolBinop unpackStr
boolBoolBinop = boolBinop unpackBool
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Esto nos permite ampliar nuestra lista de primitivas m\'as c\'omodamente:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
("=", numBoolBinop (==)),
("<", numBoolBinop (<)),
(">", numBoolBinop (>)),
("/=", numBoolBinop (/=)),
(">=", numBoolBinop (>=)),
("<=", numBoolBinop (<=)),
("&&", boolBoolBinop (&&)),
("||", boolBoolBinop (||)),
("string=?", strBoolBinop (==)),
("string<?", strBoolBinop (<)),
("string>?", strBoolBinop (>)),
("string<=?", strBoolBinop (<=)),
("string>=?", strBoolBinop (>=)),
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Ahora empieza lo interesante, implementemos condicionales sencillos, a\'un sin else:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
eval (List [Atom "if", pred, conseq, alt]) = 
     do result <- eval pred
        case result of
             Bool False -> eval alt
             otherwise  -> eval conseq
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{car} de Scheme es como \textbf{head} de Haskell, y su implementaci\'on se basa en el reconocimiento de patrones:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
car :: [LispVal] -> ThrowsError LispVal
car [List (x : xs)]         = return x
car [DottedList (x : xs) _] = return x
car [badArg]                = throwError $ TypeMismatch "pair" badArg
car badArgList              = throwError $ NumArgs 1 badArgList
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{cdr} de Scheme es  como \textbf{tail} de Haskell:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
cdr :: [LispVal] -> ThrowsError LispVal
cdr [List (x : xs)]         = return $ List xs
cdr [DottedList [_] x]      = return x
cdr [DottedList (_ : xs) x] = return $ DottedList xs x
cdr [badArg]                = throwError $ TypeMismatch "pair" badArg
cdr badArgList              = throwError $ NumArgs 1 badArgList
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\textbf{cons} es el operador \textbf{(:)} de Haskell, es decir, el que sirve para concatenar un elemento a una lista del tipo de ese elemento. Si aplicamos \textbf{cons} a una lista que s\'olo contenga elementos, obtendremos una \textbf{DottedList}:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
cons :: [LispVal] -> ThrowsError LispVal
cons [x1, List []] = return $ List [x1]
cons [x, List xs] = return $ List $ x : xs
cons [x, DottedList xs xlast] = return $ DottedList (x : xs) xlast
cons [x1, x2] = return $ DottedList [x1] x2
cons badArgList = throwError $ NumArgs 2 badArgList
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Lo siguiente es definir una funci\'on que establezca un criterio de igualdad entre valores. Esto se hace recibiendo una lista con dos elementos, los valores a comparar (los cuales tambi\'en pueden ser listas). Lo primero es comprobar que los dos valores son del mismo tipo, ya que estamos implementando una comparaci\'on fuerte. Si esto no ocurre, se devuelve falso. Si los dos valores son del mismo tipo, se les aplica la funci\'on \textbf{(==)} de Haskell:

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
eqv :: [LispVal] -> ThrowsError LispVal
eqv [(Bool arg1), (Bool arg2)]             = return $ Bool $ arg1 == arg2
eqv [(Number arg1), (Number arg2)]         = return $ Bool $ arg1 == arg2
eqv [(String arg1), (String arg2)]         = return $ Bool $ arg1 == arg2
eqv [(Atom arg1), (Atom arg2)]             = return $ Bool $ arg1 == arg2
eqv [(DottedList xs x), (DottedList ys y)] = eqv [List $ xs ++ [x], List $ ys ++ [y]]
eqv [(List arg1), (List arg2)]             = return $ Bool $ (length arg1 == length arg2) && 
                                                             (all eqvPair $ zip arg1 arg2)
     where eqvPair (x1, x2) = case eqv [x1, x2] of
                                Left err -> False
                                Right (Bool val) -> val
eqv [_, _]                                 = return $ Bool False
eqv badArgList                             = throwError $ NumArgs 2 badArgList
\end{lstlisting}
\end{tiny}
\end{minipage}

Ahora definimos un cuantificador existencial (s\'i, aunque se llame \textbf{forall}, no es universal). Esto lo que hace es crear un constructor de valor \textbf{AnyUnpacker} que recibe funciones de \textbf{Lispval} a `ThrowsError a`, para todo tipo \textbf{a} que sea instancia de la clase de tipos \textbf{Eq}. Para usarlo debemos a\~nadir a la cabecera de nuestro programa el pragma \textbf{\{-\# LANGUAGE ExistentialQuantification \#-\}}:\\

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[frame=single]
data Unpacker = forall a. Eq a => AnyUnpacker (LispVal -> ThrowsError a)
\end{lstlisting}
\end{scriptsize}
\end{minipage}

Aunque parezca muy extra~no y novedoso, indagando un poco en por qu\'e se le llama existencial nos daremos cuenta de que todo cobra sentido; esto es un constructor de tipos como otro cuaquiera, pero estamos obligando a que el tipo \textbf{a} sea instancia de la clase de tipos \textbf{Eq}. Luego, si y s\'olo si existe la instancia para \textbf{Eq} del tipo que queramos instanciar como tipo \textbf{Unpacker}, el compilador nos permitir\'a instanciarlo. Estamos ordenando nuestro c\'odigo y evitando errores en tiempo de ejecuci\'on a costa de generar potenciales errores en tiempo de compilaci\'on, puro Haskell.\\

Nuestra intenci\'on es tener tambi\'en un modo "d\'ebil" de comparar, y para ello lo que haremos ser\'a probar uno a uno todos nuestros unpackers, y desde el momento en que uno de ellos devuelva \textbf{True}, eso mismo devolveremos, y si en cambio todos devuelven \textbf{False}, entonces devolveremos \textbf{False}.\\

Lo primero que implementaremos ser\'a un helper que determinar\'a si dos \textbf{LispVal} son iguales, usando un \textbf{Unpacker}, es decir, un desempaquetador arbitrario. Aqu\'i lo que hacemos es crear un bloque \textbf{do} en el cual desempaquetamos los dos argumentos \textbf{arg1} y \textbf{arg2}, lig\'andolos a las variables \textbf{unpacked1} y \textbf{unpacked2}. Luego comprobamos su igualdad (ser\'an casi seguro \textbf{LispVal}s) y Los volvemos a meter en la m\'onada \textbf{ThrowsError}.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
unpackEquals :: LispVal -> LispVal -> Unpacker -> ThrowsError Bool
unpackEquals arg1 arg2 (AnyUnpacker unpacker) = 
             do unpacked1 <- unpacker arg1
                unpacked2 <- unpacker arg2
                return $ unpacked1 == unpacked2
        \textbf{catchError} (const $ return False)
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Ahora entra en juego \textbf{catchError}, que, recordemos, lo que hac\'ia es recibir un \textbf{Either} y si es \textbf{Right}, devolver ese mismo \textbf{Either}, si es \textbf{Left}, aplicarle la funci\'on de la derecha.\\

Veamos la definici\'on de la funci\'on \textbf{const}:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
const            :: a -> b -> a
const x _        =  x
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Veamos los tipos de cada una de las partes para entenderlo mejor:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
(const $ return False) :: Monad m => b -> m Bool
(return False) :: Monad m => m Bool
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Luego lo que est\'a haciendo \textbf{const} es permitir una currificaci\'on que, da igual lo que reciba esa funci\'on (en este caso recibe un \textbf{Left} conteniendo el error), devolver\'a siempre lo primero que recibi\'o, en este caso el resultado de \textbf{return False}, que no es otra cosa que un \textbf{ThrowsError Bool}.

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
equal :: [LispVal] -> ThrowsError LispVal
equal [arg1, arg2] = do
      primitiveEquals <- liftM or $ mapM (unpackEquals arg1 arg2) 
                         [AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]
      eqvEquals <- eqv [arg1, arg2]
      return $ Bool $ (primitiveEquals || let (Bool x) = eqvEquals in x)
equal badArgList = throwError $ NumArgs 2 badArgList
\end{lstlisting}
\end{tiny}
\end{minipage}

El tipo de \textbf{unpackEquals arg1 arg2} es \textbf{Unpacker $-\!>$ ThrowsError Bool}, por tanto, \textbf{mapM (unpackEquals arg1 arg2)} sobre la lista \textbf{[AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]} dar\'a una m\'onada \textbf{ThrowsError} conteniendo una lista de \textbf{Bool}, es decir, \textbf{ThrowsError [Bool]}. A dicha lista le aplicaremos la funci\'on \textbf{or} mediante \textbf{liftM}.\\

Construyendo un REPL\\

Un REPL (read-eval-print loop) es un bucle de lectura-evaluaci\'on-impresi\'on, es decir, nos permite usar nuestro programa como si de una consola se tratara, y es as\'i como funcionan la mayor\'ia de int\'erpretes pasados y actuales. Lo primero que haremos ser\'a crear un helper que imprima por pantalla una cadena (la salida que da el int\'erprete al evaluar algo) y limpie despu\'es el flujo:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
flushStr :: String -> IO ()
flushStr str = putStr str >> hFlush stdout
\end{lstlisting}
\end{footnotesize}
\end{minipage}

A continuaci\'on usaremos la funci\'on recientemente definida para imprimir una cadena por pantalla, limpiar el flujo y posteriormente pedir una l\'inea al usuario.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
readPrompt :: String -> IO String
readPrompt prompt = flushStr prompt >> getLine
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Sacamos de \textbf{main} el c\'odigo para parsear y evaluar una cadena y capturar los errores y lo ponemos en su propia funci\'on:\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
evalString :: Env -> String -> IO String
evalString env expr = runIOThrows $ liftM show $ (liftThrows $ readExpr expr) >>= eval env
\end{lstlisting}
\end{tiny}
\end{minipage}

Ahora creamos una funci\'on que eval\'ue una cadena e imprima el resultado:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
evalAndPrint :: Env -> String -> IO ()
evalAndPrint env expr =  evalString env expr >>= putStrLn
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Necesitamos un bucle con una condici\'on de parada (una funci\'on, \mbox{ยก}qu\'e sorpresa!), pero como en la programaci\'on funcional no existen los bucles, lo que hacemos para simular uno es llamar recursivamente a la funci\'on que definimos, \textbf{until\_}, a menos que la condici\'on de parada se cumpla, en cuyo caso devolveremos un valor de tipo tupla vac\'ia \textbf{())}.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
until_ :: Monad m => (a -> Bool) -> m a -> (a -> m ()) -> m ()
until_ pred prompt action = do 
   result <- prompt
   if pred result 
      then return ()
      else action result >> until_ pred prompt action
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Ahora que tenemos todas las piezas, s\'olo nos queda unirlas:\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
runRepl :: IO ()
runRepl = primitiveBindings >>= until_ (== "quit") (readPrompt "Lisp>>> ") . evalAndPrint
\end{lstlisting}
\end{tiny}
\end{minipage}

Ahora adaptamos nuestra funci\'on \textbf{main} para que si el programa no recibe argumentos cuando se ejecuta se ponga en marcha el int\'erprete, y si recibe un argumento (la expresi\'on a ejecutar) la eval\'ue y salga:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
main :: IO ()
main = do args <- getArgs
          if null args then runRepl else runOne $ args
\end{lstlisting}
\end{footnotesize}
\end{minipage}

A\~{n}adiendo variables y asignaci\'on:\\

Usaremos el modo de hilos de estado de Haskell, llamado \textbf{IORef}. Este m\'odulo se usa en medio de la m\'onada IO y sirve para usar variables mutables sin esfuerzo en Haskell. Necesitamos una m\'onada que contenga una lista que asocie cadenas con m\'onadas que contengan valores de tipo \textbf{LispVal}. Esto es as\'i porque hay dos maneras de modificar un entorno:\\

\begin{itemize}
  \item la funci\'on \textbf{set!} cambia el valor de una variable de la lista
  \item la funci\'on \textbf{define} a\~{n}ade una nueva variable a la lista
\end{itemize}

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
import Data.IORef

type Env = IORef [(String, IORef LispVal)]
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Definimos una funci\'on que cree un entorno vac\'io:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
nullEnv :: IO Env
nullEnv = newIORef []
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Ahora definiremos un transformador mon\'adico, es decir, algo que combina varias m\'onadas. Es una especie de \textbf{Either} currificado que puede contener dos m\'onadas, \textbf{LispError} e \textbf{IO}, es decir, encapsulamos una computaci\'on IO la posibilidad de que produzca error:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
type IOThrowsError = ErrorT LispError IO
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Como los bloques do no nos permiten usar m\'onadas de distintos tipos y tenemos muchas funciones que hacen uso de \textbf{ThrowsError}, debemos definir un lifter que pase de una m\'onada a la otra:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
liftThrows :: ThrowsError a -> IOThrowsError a
liftThrows (Left err) = throwError err
liftThrows (Right val) = return val
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Tambi\'en queremos un helper que ejecute la acci\'on \textbf{IOThrowsError}, ejecute la computaci\'on del error y capture los errores, devolviendo una acci\'on \textbf{IO}. Esto usa \textbf{trapError} para convertir los valores de error en su representaci\'on de cadena, y luego ejecuta la computaci\'on mediante \textbf{runErrorT}. Luego se extrae el valor y se envuelve en la m\'onada \textbf{IO}:\\

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[frame=single]
runIOThrows :: IOThrowsError String -> IO String
runIOThrows action = runErrorT (trapError action) >>= return . extractValue
\end{lstlisting}
\end{scriptsize}
\end{minipage}

Se muestra el tipo de \textbf{readIORef} por claridad. Definimos ahora una funci\'on que devuelva un booleano que indique si una variable est\'a ligada o no:\\

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
readIORef :: IORef a -> IO a

isBound :: Env -> String -> IO Bool
isBound envRef var = readIORef envRef >>= return . maybe False (const True) . lookup var
\end{lstlisting}
\end{tiny}
\end{minipage}

Ahora repetimos la estrategia pero para obtener un valor de tipo \textbf{LispVal} dentro de la m\'onada \textbf{IOThrowsError}:\\ 

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
liftIO :: IO a -> m a

getVar :: Env -> String -> IOThrowsError LispVal
getVar envRef var  =  do env <- liftIO $ readIORef envRef
                         maybe (throwError $ UnboundVar "Getting an unbound variable" var)
                               (liftIO . readIORef)
                               (lookup var env)
\end{lstlisting}
\end{tiny}
\end{minipage}

Ahora definiremos una funci\'on para cambiar el valor de una variable. Es muy parecida a la anterior pero hace uso de dos funciones nuevas:

\begin{itemize}
  \item \textbf{flip}: invierte el orden de los argumentos de una funci\'on.
  \item \textbf{writeIORef}: escribe un valor en el \textbf{IORef}.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
setVar :: Env -> String -> LispVal -> IOThrowsError LispVal
setVar envRef var value = do env <- liftIO $ readIORef envRef
                             maybe (throwError $ UnboundVar "Setting an unbound variable" var)
                                   (liftIO . (flip writeIORef value))
                                   (lookup var env)
                             return value
\end{lstlisting}
\end{tiny}
\end{minipage}

Una funci\'on algo m\'as interesante es aquella capaz de definir una nueva variable. Para ello se ha de crear un nuevo \textbf{IORef} con el valor que tendr\'a en principio, luego crear un par (nombreVariable, valorIORef) para a\~{n}adirlo al principio de la lista (esto se hace por eficiencia):\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
defineVar :: Env -> String -> LispVal -> IOThrowsError LispVal
defineVar envRef var value = do
     alreadyDefined <- liftIO $ isBound envRef var
     if alreadyDefined
        then setVar envRef var value >> return value
        else liftIO $ do
             valueRef <- newIORef value
             env <- readIORef envRef
             writeIORef envRef ((var, valueRef) : env)
             return value
\end{lstlisting}
\end{footnotesize}
\end{minipage}

La siguiente funci\'on enriquece un entorno con una lista de variables y valores, y para ello usa una tuber\'ia mon\'adica y dos helpers:

\begin{itemize}
  \item \textbf{extendEnv} a\~{n}ade al principio de un entorno una lista de pares 
  \item \textbf{addBinding} recibe un par (nombre, valor) y devuelve un par adaptado para ser a\~{n}adido a un entorno.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[frame=single]
bindVars :: Env -> [(String, LispVal)] -> IO Env
bindVars envRef bindings = readIORef envRef >>= extendEnv bindings >>= newIORef
     where extendEnv bindings env = liftM (++ env) (mapM addBinding bindings)
           addBinding (var, value) = do ref <- newIORef value
                                        return (var, ref)
\end{lstlisting}
\end{scriptsize}
\end{minipage}

A\~{n}adimos despu\'es de la ecuaci\'on para if las siguientes dos ecuaciones:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
eval env (List [Atom "set!", Atom var, form]) =
     eval env form >>= setVar env var
eval env (List [Atom "define", Atom var, form]) =
     eval env form >>= defineVar env var
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Actualizamos el resto de funciones de evaluaci\'on:\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
evalAndPrint :: Env -> String -> IO ()
evalAndPrint env expr =  evalString env expr >>= putStrLn
\end{lstlisting}
\end{footnotesize}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{tiny}
\begin{lstlisting}[frame=single]
evalString :: Env -> String -> IO String
evalString env expr = runIOThrows $ liftM show $ (liftThrows $ readExpr expr) >>= eval env
\end{lstlisting}
\end{tiny}
\end{minipage}

Adaptamos ahora nuestras funciones de ejecuci\'on para que empiecen con el entorno vac\'io:\\

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[frame=single]
runOne :: String -> IO ()
runOne expr = nullEnv >>= flip evalAndPrint expr

runRepl :: IO ()
runRepl = nullEnv >>= until_ (== "quit") (readPrompt "Lisp>>> ") . evalAndPrint
\end{lstlisting}
\end{scriptsize}
\end{minipage}

Finalmente cambiamos nuestra funci\'on \textbf{main} para que s\'olo funcione con un argumento o ninguno.\\

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[frame=single]
main :: IO ()
main = do args <- getArgs
          case length args of
               0 -> runRepl
               1 -> runOne $ args !! 0
               otherwise -> putStrLn "Program takes only 0 or 1 argument"
\end{lstlisting}
\end{scriptsize}
\end{minipage}