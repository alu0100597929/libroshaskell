%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapter 4 : T'itulo del Cap'itulo cuatro
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

En el cap\'itulo ~\ref{chapter:tres} se describi\'o el lenguaje Scheme, dando una idea general sobre el mismo. En el presente cap\'itulo se tratar\'a de explicar el funcionamiento del programa principal del presente Trabajo Fin de Grado.\\

\section{Estructura general del programa}
\label{3:sec1}

En un programa escrito en Haskell, la mayor\'ia de funciones son puras, es decir, s\'olo conocen el conjunto de argumentos que reciben y s\'olo pueden actuar sobre ellos, devolviendo al final de su ejecuci\'on un valor de su tipo de retorno.\\

El concepto descrito de funci\'on pura no se corresponde con el de las funciones de lenguajes imperativos como C,C++ o Java. En los mencionados lenguajes, las funciones no tienen demasiado que ver con las funciones matem\'aticas formales. Las funciones de C, C++ o Java pueden imprimir por pantalla, interactuar con el usuario y, en definitiva, recibir informaci\'on que est\'a m\'as all\'a del \'ambito de sus par\'ametros.\\

Para superar esta dificultad se cre\'o el concepto de m\'onada. Las m\'onadas tienen fama de algo m\'as que abstracto, muy dif\'icil de entender, y estoy de acuerdo en que f\'aciles no son, al menos al principio. Las m\'onadas, en esencia, son constructos que se realizan con lambdas estructuradas de un modo espacial y con sus argumentos, y de este modo se consigue encapsular una computaci\'on o acci\'on. Como un argumento podr\'ia depender de argumentos de lambdas anteriores, se consigue, en el caso de la m\'onada IO, que las acciones se ejecuten en el orden deseado. Recordemos que Haskell, al ser un lenguaje funcional, ejecuta ``todo a la vez'', y mediante las m\'onadas, conseguimos una ejecuci\'on ordenada.\\

En el programa que se pasar\'a a describir se ha usado varias m\'onadas, cada cual cumple una funci\'on distinta, que, sin m\'as dilaci\'on, pasamos a explicar.\\

El tipo \textbf{IO} es instancia de la clase de tipos Monad, m'onada es un concepto, decir que un valor pertenece a la clase de tipos \textbf{Monad} es decir:\\

\begin{itemize}
  \item 1) Hay (un cierto tipo de) informaci\'on oculta adjunta a este valor.
  \item 2) La mayor\'ia de funciones no se tienen que preocupar de esa informaci'on.
\end{itemize}

En este caso:\\

La informaci\'on extra son acciones IO que se ejecutar\'an usando los valores que se van pasando de una a otra; mientras que el valor b\'asico (el cual tiene informaci\'on adjunta) es void, la tupla vac\'ia o unidad, ().\\

IO [String] e IO () pertenecen al mismo tipo, el de la m\'onada IO, pero tienen distintos tipos base. Act\'uan sobre (y se pasan unos a otros) valores de distintos tipos, [String] y ().\\

Los valores con informaci\'on oculta adjunta son llamados valores mon\'adicos.\\

Los valores mon\'adicos se suele llamar acciones, porque la manera m\'as f\'acil de pensar en el uso de la m\'onada IO es pensar en una secuencia de acciones afectando al mundo exterior. Cada acci\'on de la mencionada secuencia de acciones podr\'ia actuar sobre valores b\'asicos (no mon\'adicos). Por tanto:\\

\begin{itemize}
  \item m a es una acci\'on
  \item (a -> m ()) es una funci\'on que devuelve una acci\'on que contiene la tupla vac\'ia o unidad ().
\end{itemize}

Parsec (en realidad, genParser) es otro ejemplo de m\'onada: en este caso, la informaci\'on extra que se encuentra oculta es toda aquella relativa a la posici\'on en la cadena de entrada, registro de backtracking, conjuntos first y follow...etc\'etera.\\

La funci\'on parse devuelve un Either, que tendremos que manejar seg\'un construya un Left (ParseError) o Right (valor correcto).\\

readExpr: recibe una String (la cadena de entrada) y devuelve otra String con informaci\'on de lo que haya parseado.\\

readExpr utiliza la funci\'on parse, que devuelve un Either, que readExpr maneja seg\'un construya un Left (error) o Right (valor correcto).\\

Luego se trata de ir parseando los diferentes tokens de Scheme y luego construir, mediante un constructor de valor para el tipo LispVal, un valor determinado.\\

Para ello se aplican parsers de Parsec y se extrae su informaci\'on oculta de aquello que han parseado mediante el constructo <-, o se usa liftM funci\'on valor\_mon\'adico.\\

Parsers recursivos:\\

En un lenguaje funcional la recursividad es uno de los m\'etodos m\'as interesantes. En un lenguaje como Scheme y muchos otros, encontramos estructuras de datos que pueden contener a otras, por ejemplo, una lista puede contener:\\

\begin{itemize}
  \item otras listas (sean normales o dotted)
  \item cualquier otra expresi\'on.
\end{itemize}

Por tanto, en el int\'erprete se llama recursivamente al parser principal, parseExpr :: Parser LispVal, con el objetivo de parsear lo que haya dentro de cada expresi\'on.\\

Por ejemplo, en parseList y parseDottedList se usan, respectivamente:\\

\begin{itemize}
  \item sepBy parseExpr spaces
  \item endBy parseExpr spaces
\end{itemize}

Los cuales van a devolver una [LispVal], justo el argumento que necesita el constructor de tipo List y el primero que necesita DottedList.\\

Por tanto, vemos que mediante el uso de sepBy y endBy estamos haciendo llamadas recursivas a readExpr y por ello nuestro parser es capaz de lidiar con estructuras anidadas de manera casi gratuita.\\

Lo primero de todo es hacer LispVal instancia de Show para poder imprimir por pantalla los valores de tipo LispVal.\\

Para ello se crea la funci\'on showVal :: LispVal -> String y se iguala a show (instance Show LispVal where show = showVal). Para los dos tipos de listas, List y DottedList, se usa la funci\'on unwordsList:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
unwordsList :: [LispVal] -> String
unwordsList = unwords . map showVal
\end{lstlisting}
\end{small}
\end{minipage}

Ahora empezamos con el evaluador propiamente dicho:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
eval :: LispVal -> LispVal
eval val@(String _) = val
eval val@(Number _) = val
eval val@(Bool _) = val
eval (List [Atom "quote", val]) = val
\end{lstlisting}
\end{small}
\end{minipage}

LispVal se puede ver como una expresi\'on, y cambiaremos LispVal para que devuelva una expresi\'on en vez de su valor de cadena de car\'acteres.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
readExpr :: String -> LispVal
readExpr input = case parse parseExpr "lisp" input of
    Left err -> String $ "No match: " ++ show err
    Right val -> val
\end{lstlisting}
\end{small}
\end{minipage}

Cambiamos el c\'odigo de la funci\'on main para que eval\'ue las expresiones en vez de s\'olo imprimirlas por pantalla:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
main :: IO ()
main = getArgs >>= print . eval . readExpr . head
\end{lstlisting}
\end{small}
\end{minipage}

A\~nadimos a la funci\'on eval una ecuaci\'on que nos permitir\'a aplicar funciones a sus argumentos (para aplicar funciones se debe poner una lista cuyo primer elemento es el nombre de la funci\'on y luego los dem\'as elementos ser\'an los argumentos de dicha funci\'on):\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
eval (List (Atom func : args)) = apply func $ map eval args
\end{lstlisting}
\end{small}
\end{minipage}

Como vemos, tenemos hecha una ecuaci\'on que es recursiva, mapea eval sobre los argumentos, con lo cual ya tenemos resuelto el problema de evaluar listas anidadas de manera "gratuita".\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
apply :: String -> [LispVal] -> LispVal
apply func args = maybe (Bool False) ($ args) $ lookup func primitives
\end{lstlisting}
\end{small}
\end{minipage}

La funci\'on maybe recibe un valor por defecto, una funci\'on, y un valor de tipo Maybe. Si el valor de tipo Maybe es Nothing, la funci\'on devuelve el valor por defecto. Si no, aplica la funci\'on al valor dentro del Just y devuelve el resultado.\\

\begin{minipage}{\linewidth}
\begin{footnotesize}
\begin{lstlisting}[frame=single]
primitives :: [(String, [LispVal] -> LispVal)]
primitives = [("+", numericBinop (+)),
              ("-", numericBinop (-)),
              ("*", numericBinop (*)),
              ("/", numericBinop div),
              ("mod", numericBinop mod),
              ("quotient", numericBinop quot),
              ("remainder", numericBinop rem)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> LispVal
numericBinop op params = Number $ foldl1 op $ map unpackNum params
 
unpackNum :: LispVal -> Integer
unpackNum (Number n) = n
unpackNum (String n) = let parsed = reads n :: [(Integer, String)] in 
                           if null parsed 
                              then 0
                              else fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum _ = 0
\end{lstlisting}
\end{footnotesize}
\end{minipage}

Crearemos una m\'onada llamada ThrowsError, que en realidad se comporta como la m\'onada Either:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
type ThrowsError = Either LispError
\end{lstlisting}
\end{small}
\end{minipage}

la l\'inea de arriba est\'a currificada, se podr\'ia escribir as\'i tambi\'en:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
type ThrowsError b = Either LispError b
\end{lstlisting}
\end{small}
\end{minipage}

ThrowsError es, por tanto, una m\'onada que puede contener LispError (en el caso de Left) o un tipo b, que en nuestro programa es LispVal (en el caso de Right). Por tanto, cuando accedemos a su interior, encontraremos un LispError o un LispVal. Es decir, estamos definiendo un tipo que puede ser del tipo b, o bien dar error.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
readExpr :: String -> ThrowsError LispVal
eval :: LispVal -> ThrowsError LispVal
showVal :: LispVal -> String
\end{lstlisting}
\end{small}
\end{minipage}

Either es una m\'onada en la cual bind para su ejecuci\'on cuando encuentra un Left, devolviendo ese Left y ahorrando mucho tiempo de computaci\'on.\\

La m\'onada Either tambi\'en provee otras dos funciones a parte de las mon\'adicas est\'andar:\\

throwsError: recibe un valor de tipo Error y lo eleva al constructor Left (error) de un Either.\\

¿Por qu\'e se usa throwsError? Porque en realidad, no existe el constructor de valor LispError, sino que es un constructor de tipo. Por ello, mediante throwsError, creamos un Left (el LispError concreto que sea), lo cual es un resultado de tipo ThrowsError LispVal, el tipo retorno de readExpr.\\

catchError: recibe un valor Either (una acci\'on) y si es Right, lo devuelve, si es Left,
le aplica la funci\'on que recibe (en este caso est\'a hardcoded, y lo que hace es pasar del Left a un valor normal de LispVal). El sentido de todo esto es que
el Either resultado siempre tenga un valor Right:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
trapError action = catchError action (return . show)
\end{lstlisting}
\end{small}
\end{minipage}

De este modo lo que hacemos es transformar los errores (Left) en su representaci\'on String metidos en la m\'onada Either.\\

Ahora que tenemos asegurado que todos los valores van a ser Right, hagamos un accessor
efectivo:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
extractValue :: ThrowsError a -> a
extractValue (Right val) = val
\end{lstlisting}
\end{small}
\end{minipage}

La funci\'on parse devuelve un Either, que tendremos que manejar seg\'un construya un Left (ParseError) o Right (valor correcto). parse :: (Stream s Identity t) => Parsec s () a -> SourceName -> s -> Either ParseError a\\

Ahora eval va a devolver un valor mon\'adico, con lo cual, en vez de map debemos usar mapM, y usar return para encapsular en valores mon\'adicos los resultados de eval.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
mapM :: Monad m => (a -> m b) -> [a] -> m [b]:
\end{lstlisting}
\end{small}
\end{minipage}

mapM mf xs recibe una funci\'on mon\'adica (con tipo Monad m => (a -> m b)) y la aplica a cada elemento en la lista xs; el resultado es una lista (con elementos del tipo b, en este caso) dentro de una m\'onada. Por tanto mapM eval args da como resultado [LispVal].\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
eval :: LispVal -> ThrowsError LispVal
eval val@(String _) = return val
eval val@(Number _) = return val
eval val@(Bool _) = return val
eval (List [Atom "quote", val]) = return val
eval (List (Atom func : args)) = mapM eval args >>= apply func
eval badForm = throwError $ BadSpecialForm "Unrecognized special form" badForm

apply :: String -> [LispVal] -> ThrowsError LispVal
apply func args = maybe (throwError $ NotFunction "Unrecognized primitive function args" func)
                        ($ args)
                        (lookup func primitives)

primitives :: [(String, [LispVal] -> ThrowsError LispVal)]

numericBinop :: (Integer -> Integer -> Integer) -> [LispVal] -> ThrowsError LispVal
numericBinop op           []  = throwError $ NumArgs 2 []
numericBinop op singleVal@[_] = throwError $ NumArgs 2 singleVal
numericBinop op params        = mapM unpackNum params >>= return . Number . foldl1 op

unpackNum :: LispVal -> ThrowsError Integer
unpackNum (Number n) = return n
unpackNum (String n) = let parsed = reads n in 
                           if null parsed 
                             then throwError $ TypeMismatch "number" $ String n
                             else return $ fst $ parsed !! 0
unpackNum (List [n]) = unpackNum n
unpackNum notNum     = throwError $ TypeMismatch "number" notNum
\end{lstlisting}
\end{small}
\end{minipage}

Aqu\'i lo m\'as complicado es saber el tipo de evaled, as\'i que vayamos por partes:\\

\begin{itemize}

\item 1) $readExpr (args !! 0) >>= eval$: readExpr da un ThrowsError LispVal, luego bind lo que hace es pasar el LispVal a eval, y acaba dando otro ThrowsError LispVal.

\item 2) liftM show sobre la m\'onada ThrowsError LispVal da una ThrowsError String.

\item 3) hacer return sobre una ThrowsError String nos devuelve un IO (Either ThrowsError String), y esto se hace para que al operar con el constructo <- sigamos teniendo el Either ThrowsError String, que es lo que recibe trapError.

* Recuerda, si estamos trabajando en un do de una m\'onada tipo IO, el return va a envolver el dato en una m\'onada IO, y esto es v\'alido para cualquier m\'onada.

\item 4) trapError nos devuelve un Either del tipo Either String, porque recordemos, Left era LispError, Right era String, y catchError siempre devuelve Right.

\item 5) extrackValue nos devuelve un String.
\end{itemize}

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
main :: IO ()
main = do
     args <- getArgs
     evaled <- return $ liftM show $ readExpr (args !! 0) >>= eval
     putStrLn $ extractValue $ trapError evaled
\end{lstlisting}
\end{small}
\end{minipage}

Todas las funciones cuyo primer argumento es LispVal deben usar pattern matching para saber qu\'e constructor de valor se ha usado para crear el mencionado LispVal.\\

car de Scheme es como head de Haskell. cdr de Scheme es  como tail de Haskell.\\

cons es el operador (:) de Haskell, es decir, el que sirve para concatenar un elemento a una lista del tipo de ese elemento. Si aplicamos cons a una lista que no contenga al menos una lista, obtendremos una DottedList.\\

Ahora definimos un cuantificador existencial (s\'i, aunque se llame forall, no es universal). Esto lo que hace es crear un constructor de valor AnyUnpacker que recibe funciones de Lispval a ThrowsError a, para todo tipo a que sea instancia de la clase de tipos Eq:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
data Unpacker = forall a. Eq a => AnyUnpacker (LispVal -> ThrowsError a)

unpackEquals :: LispVal -> LispVal -> Unpacker -> ThrowsError Bool
unpackEquals arg1 arg2 (AnyUnpacker unpacker) = 
             do unpacked1 <- unpacker arg1
                unpacked2 <- unpacker arg2
                return $ unpacked1 == unpacked2
        catchError (const $ return False)
\end{lstlisting}
\end{small}
\end{minipage}

Aqu\'i lo que hacemos es crear un bloque do en el cual desempaquetamos los dos argumentos arg1 y arg2, lig\'andolos a las variables unpacked1 y unpacked2. Luego comprobamos su igualdad (ser\'an casi seguro LispVals) y Los volvemos a meter en la m\'onada ThrowsError.\\

Ahora entra en juego catchError, que, recordemos, lo que hac\'ia es recibir un Either y si es Right, devolver ese mismo Either, si es Left, aplicarle la funci\'on de la derecha.\\

Veamos en qu\'e consiste \textbf{cons} para saber por qu\'e se ha usado.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
const            :: a -> b -> a
const x _        =  x
\end{lstlisting}
\end{small}
\end{minipage}

Veamos los tipos de cada una de las partes para entenderlo mejor:\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
Prelude Control.Monad.Except> :t (const $ return False)
(const $ return False) :: Monad m => b -> m Bool
Prelude Control.Monad.Except> :t (return False)
(return False) :: Monad m => m Bool
\end{lstlisting}
\end{small}
\end{minipage}

Luego lo que est\'a haciendo const es permitir una currificaci\'on que, da igual lo que reciba esa funci\'on (en este caso recibe un Left conteniendo el error), devolver\'a siempre lo primero que recibi\'o, en este caso el resultado de return False, que no es otra cosa que un ThrowsError Bool.\\

\begin{minipage}{\linewidth}
\begin{small}
\begin{lstlisting}[frame=single]
equal :: [LispVal] -> ThrowsError LispVal
equal [arg1, arg2] = do
      primitiveEquals <- liftM or $ mapM (unpackEquals arg1 arg2) 
                         [AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool]
      eqvEquals <- eqv [arg1, arg2]
      return $ Bool $ (primitiveEquals || let (Bool x) = eqvEquals in x)
equal badArgList = throwError $ NumArgs 2 badArgList
\end{lstlisting}
\end{small}
\end{minipage}

El tipo de unpackEquals arg1 arg2 es Unpacker -> ThrowsError Bool, por tanto, mapM (unpackEquals arg1 arg2) sobre la lista [AnyUnpacker unpackNum, AnyUnpacker unpackStr, AnyUnpacker unpackBool] dar\'a una m\'onada ThrowsError conteniendo una lista de Bool, es decir, ThrowsError [Bool]. A dicha lista le aplicaremos la funci\'on or mediante liftM.\\

Para lidiar con las cl\'ausulas \textbf{else} se ha realizado un ``hack'', cada vez que eval se encuentra un else, devuelve un Bool True para que siempre se ejecute esa expresi\'on.\\