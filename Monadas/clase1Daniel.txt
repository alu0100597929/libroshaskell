Daniel D√≠az

hola
acabo de llegar
y he le√≠do tu email

Francisco Nebrera Perdomo

eys
qu√© tal ni√±o?
estaba ley√©ndome el pearls of functional programming design
est√° curioso
xd

Daniel D√≠az

hola
bien, bien

Francisco Nebrera Perdomo

las m√≥nadas las ten√≠a aparcadas
xD

Daniel D√≠az

bueno, como te dije, aunque ahora pienses lo contrario, es una clase como otra cualquiera

Francisco Nebrera Perdomo

okok

Daniel D√≠az

de momento, podr√≠amos fijarnos en sus m√©todos
y ver diferentes instancias
y entender qu√© es la notaci√≥n "do"
no s√©, siempre puedes preguntarme lo que quieras

Francisco Nebrera Perdomo

okok

Daniel D√≠az

tengo poca experiencia como profesor jaja

Francisco Nebrera Perdomo

xDDDDDDDDDDDd

Daniel D√≠az

en cualquier caso... Monad tiene dos m√©todos clave...
el famoso "bind"
y el "return"

Francisco Nebrera Perdomo

ok
eso "lo entiendo"
xd

Daniel D√≠az

¬øhas le√≠do algo sobre kinds?

Francisco Nebrera Perdomo

un poco
se que son cositas en plan
* -> *
en plan

Daniel D√≠az

s√≠, exacto

Francisco Nebrera Perdomo

es una cosa que recibe una cosa, y da otra

Daniel D√≠az

es importante saber que para que un tipo pueda ser instancia de Monad
tiene que tener kind "* -> *"

Francisco Nebrera Perdomo

ok

Daniel D√≠az

claro, es como una funci√≥n, pero de tipos
por ejemplo
Maybe es de kind * -> *
porque dado un tipo "a"
"Maybe a" es otro tipo
no?

Francisco Nebrera Perdomo

no se
maybe a ya estar√≠a definido
en cuanto se crea
es decir, creo que maybe a

Daniel D√≠az

quiz√°s me expliqu√© mal
Maybe :: * -> *
Maybe a :: *
ahora ya (Maybe a) no puede ser aplicado a ning√∫n tipo m√°s
Either :: * -> * -> *
Either String :: * -> *
etc... creo que se ve

Francisco Nebrera Perdomo

sisi
es curry
algo parecido me estas ense√±ando

Daniel D√≠az

telefono

Francisco Nebrera Perdomo

ko
ok

Daniel D√≠az

jazztel, mu√©ranse

Francisco Nebrera Perdomo

jkaskjasjkaskjas
xD
me tienen negro a m√≠ tb
t√∫ diles que est√°s currando
y listo

Daniel D√≠az

ok
pues lo dicho, el tipo tiene que tener kind "* -> *" para poder ser instancia de Monad
tener un parametro libre, digamos
"Bool" no podr√≠a... "Either" tampoco... "Either Bool" s√≠...
lo mismo pasa con la clase Functor

Francisco Nebrera Perdomo

eso te iba a decir
eso s√≠ que me lo estudi√© y me lo sab√≠a
pero en el trabajo me tienen haciendo otras cosas

Daniel D√≠az

genial, yo no s√© lo que sabes y lo que no, as√≠ que voy poco a poco

Francisco Nebrera Perdomo

perfecto
en realidad ese conocimiento es necesario
v√≠ que en ghc 7.10, las m√≥nadas est√°n obligadas a ser Applicative

Daniel D√≠az

gracias a Dios (GHC), por fin

Francisco Nebrera Perdomo

jajaja xD

Daniel D√≠az

pero bueno, eso lo vemos m√°s adelante
si quieres

Francisco Nebrera Perdomo

sisi
yo te dejo
no te preocupes que si no entiendo algo me quejo
xD

Daniel D√≠az

los m√©todos de Monad son (>>= ) :: m a -> (a -> m b) -> m b
y return :: a -> m a
donde a, b son cualquier cosa
y m es la m√≥nada que estamos instanciando
el tipo que estamos instanciando a las clase Monad

Francisco Nebrera Perdomo

ok

Daniel D√≠az

cuando escribes la instancia, como cuando escribes muchas funciones en Haskell, el tipo  te va a forzar a escribir lo √∫nico que tiene sentido escribir
voy a definir un tipo que, aunque en apariencia in√∫til, tiene sus usos pr√°cticos
data Id a = Id a
el tipo identidad
en la pr√°ctica, dado un tipo "a", los elementos que puedes construir en "a" y los que puedes construir en "Id a" son pr√°cticamente los mismos
por eso se llama Identidad

Francisco Nebrera Perdomo

ok

Daniel D√≠az

Id puede ser instanciado en la clase Functor
seguro que imaginas c√≥mo

Francisco Nebrera Perdomo

instance Id Functor where
id x = x
algo as√≠
no se xD

Daniel D√≠az

ok
s√≥lo hay un m√©todo en la clase Functor
fmap :: (a -> b) -> f a -> f b
donde "f" es el tipo que estamos instanciando, el resto es polim√≥rfico
voy a escribir la clase para aclarar algo...
class Functor f where
  fmap :: (a -> b) -> f a -> f b
como ves, en la definici√≥n aparece "Functor f"
es en ese momento donde se especifica: en los m√©todos que vo ya describir abajo, "f" es el tipo de cada instancia de esta clase
entonces, para hacer una instancia la clase, hay que escribir una definici√≥n de cada m√©todo, sustituyendo el par√°metro "f" (en este caso) con el que estamos instanciando
¬øse entiende?

Francisco Nebrera Perdomo

un momento a ver
si es decir
que tu en
fmap :: ...........
cambias f por
Id a

Daniel D√≠az

mmmm, casi
necesitamos un tipo de kind "* -> *"
"Id a" tiene kind *

Francisco Nebrera Perdomo

ok
pues por Id solo

Daniel D√≠az

exacto

Francisco Nebrera Perdomo

okok xD

Daniel D√≠az

el kind que hace falta lo calcula GHC a partir de la definici√≥n de la clase
en fmap
puede ver que "f" est√° siendo aplicado a un tipo
de ah√≠ deduce que el kind tiene que ser * -> *

Francisco Nebrera Perdomo

ok

Daniel D√≠az

vale
entonces, para hacer Id instancia de Functor
necesitamos definir fmap :: (a -> b) -> Id a -> Id b
dicho esto, quiero apuntar algo
el operador (->), en ausencia de par√©ntesis, asocia a la derecha
osea que (a -> b) -> Id a -> Id b
significa (a -> b) -> (Id a -> Id b)
no ((a -> b) -> Id a) -> Id b

Francisco Nebrera Perdomo

sisi

Daniel D√≠az

ten eso en cuenta

Francisco Nebrera Perdomo

eso es por la currificaci√≥n

Daniel D√≠az

bueno, es porque tiene que asociar para alguna parte
si no cu√°l de las dos cosas significa?
habr√≠a varias opciones...

Francisco Nebrera Perdomo

si xD
me refiero a que la aplicaci√≥n parcial

Daniel D√≠az

esto lo hacen todos los lenguajes

Francisco Nebrera Perdomo

empieza por la izq
por eso asocia a la derecha

Daniel D√≠az

aha
ok, s√≠
sabiendo esto
(a -> b) -> Id a -> Id b = (a -> b) -> (Id a -> Id b)
es decir
fmap coge una funci√≥n
y la "eleva" sobre el functor
en este caso Id
osea, toma una funci√≥n, y la convierte en una que toma elementos en el funtor y los devuelve en el funtor tambi√©n

Francisco Nebrera Perdomo

okok
es verdad
ciert√≠simo
es asombroso lo claro que lo tienes todo xD

Daniel D√≠az

genial, ese es el prop√≥sito de Functor

Francisco Nebrera Perdomo

pero s√≠, hab√≠a le√≠do eso en learn youa haskell
que los aplicativos son lo mismo

Daniel D√≠az

yo me dedico a esto...

Francisco Nebrera Perdomo

pero para hacer un lift en varios funtores
si
una cosa es que te dediques

Daniel D√≠az

ya lo ver√°s todo claro

Francisco Nebrera Perdomo

y otra cosa que te guste y sepas
xD

Daniel D√≠az

jaja en mi trabajo programo en Haskell, y en mi tiempo libre... tambi√©n
jaja

Francisco Nebrera Perdomo

ajskjaskjas

Daniel D√≠az

bueno, seguimos

Francisco Nebrera Perdomo

en realidad es un vicio
sisi te dejo
k soy un palicoso

Daniel D√≠az

ok, pues cu√°l es la instancia a Functor de Id?

Francisco Nebrera Perdomo

pues
dir√≠a que es simplemente
un fmap
que recibe una funcion
es decir
fmap f x = f x
algo as√≠
simplemente da la funcion aplicada
el resultado

Daniel D√≠az

sin embargo, los tipos tienen que encajar
todo trata de encajar los tipos
ese es el juego
f :: a -> b
x :: a
luego... f x :: b

Francisco Nebrera Perdomo

ok

Daniel D√≠az

y quieres un resultado de tipo Id b

Francisco Nebrera Perdomo

fmap f x = Id (f x)

Daniel D√≠az

bien, exacto

Francisco Nebrera Perdomo

asi lo mete
en un contexto Id
o algo as√≠ era
xd

Daniel D√≠az

bueno, Id :: a -> Id a
con eso te vale
la cuesti√≥n es saber el tipo de cada cosa

Francisco Nebrera Perdomo

okok
vale

Daniel D√≠az

y hacer que todas las piezas encajen
pues vamos a Monad
class Monad m where
  (>>= ) :: m a -> (a -> m b) -> m b
  return :: a -> m a
esta vez tenemos dos m√©todos que definir
empezemos por el que casi siempre es m√°s f√°cil
"return"
te he dado el tipo de Id antes as√≠ que...
yo dir√≠a que encaja bastante bien

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

return = Id

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

con eso estamos
vamos al bind
el primer argumento es de tipo "Id a"
vamos a hacer "pattern matching"

Francisco Nebrera Perdomo

ok

Daniel D√≠az

Id a >>= f = ...
el segundo es una funci√≥n, as√≠ que pongo un "f" y listo

Francisco Nebrera Perdomo

ok

Daniel D√≠az

ahora, con los elementos que disponemos, s√≥lo tenemos que pensar que puedo hacer para acabar con algo de tipo "Id b" a la derecha
sabiendo que "a :: a"
y "f :: a -> Id b"
creo que es bastante obvio
pero te dejo que me digas

Francisco Nebrera Perdomo

ok
Id (f a)

Daniel D√≠az

pues no era tan obvio
a ver, calcula el tipo de esa expresi√≥n
que acabas de poenr

Francisco Nebrera Perdomo

ops
sorry
f a
lo da directamente en Id b

Daniel D√≠az

s√≠, es una mera aplicaci√≥n de f

Francisco Nebrera Perdomo

en eso siempre fallo
me trabo en esa idiotez
xD
puta bida

Daniel D√≠az

pues enhorabuena, acabas de definir una m√≥nada

Francisco Nebrera Perdomo

xDDDDDDDDD
okok, guay
es decir ahora puedo

Daniel D√≠az

todo es hacer encajar tipos

Francisco Nebrera Perdomo

okok

Daniel D√≠az

como en todo Haskell...
claro que, cuanto m√°s complejo sea el tipo
m√°s dif√≠cil es el juego de encajar los tipos
ahora, qu√© carajos es la notaci√≥n "do"

Francisco Nebrera Perdomo

pues
es un azucar sintactico
para unas lambdas raras con el bind

Daniel D√≠az

pues, es una forma de escribir los operadores ">>=" y ">>" sin escribirlos...

Francisco Nebrera Perdomo

y luego usa >> tambi√©n

Daniel D√≠az

s√≠...
por cierto
(>>) :: m a -> m b -> m b
por defecto
se define como
m >> k = m >>= \_ -> k
as√≠ que es s√≥lo para ahorrate la lambda
que ignora su argumento

Francisco Nebrera Perdomo

ese operador me traba a√∫n m√°s que el bind
estuve haciendo ciertas pruebas con los ejemplso de LYAH
y lo √∫nico que hac√≠a era pasar de todo lo anterior
y dar un nuevo valor a la m√≥nada
eso es lo que entend√≠

Daniel D√≠az

m >> k = m >>= \_ -> k
ah√≠ te dice lo que hace!
digamos que m :: m a, para alguna instancia de Monad m
la funci√≥n de la derecha es constantemente k
as√≠ que el valor en "m" realmente es ignorado 
y devuelve "k"

Francisco Nebrera Perdomo

s√≠
pero su tipo es
(>>) :: m a -> m b -> m b
recibe dos m√≥nadas
para devolver la segunda

Daniel D√≠az

casi
realmente no s√≥lo hace eso
te hace un bind, pero con una funci√≥n constante
que no depende de la "a" digamos

Francisco Nebrera Perdomo

si

Daniel D√≠az

veamos con Id

Francisco Nebrera Perdomo

pero tu le pasaste dos m√≥nadas
de donde saca la funci√≥n?

Daniel D√≠az

veamos con Id c√≥mo funciona

Francisco Nebrera Perdomo

okok

Daniel D√≠az

Id 2 >>= (Id . (+1)) ?

Francisco Nebrera Perdomo

a ver
Id 3
ser√≠a el resultado creo

Daniel D√≠az

s√≠
ok, en este caso (>>) va a hacer lo que dices... as√≠ que es mal ejemplo para hacerte ver que no es simplemente ignorar el primer argumento
en cualquier caso lo hacemos
por definici√≥n: m >> k = m >>= \_ -> k
as√≠ que, si paso (Id 3 >> Id 4), qu√© hace?
primero
Id 3 >>= \_ -> Id 4
lo transforma en un bind, ves?

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

ahora, por nuestra definici√≥n de bind
lo transforma en
(\_ -> Id 4) 3

Francisco Nebrera Perdomo

joder
as√≠ paso a paso s√≠ que se entiende
:D

Daniel D√≠az

claro, ahora aplica esa funci√≥n
y te queda Id 4

Francisco Nebrera Perdomo

ciert√≠simo,

Daniel D√≠az

si lo hicieras con "a" y "b"
podr√≠as demostrar que, en general, simplemente se queda con el segundo
pero esta propiedad no la comparten todas las m√≥nadas
la siguiente que ver√≠amos, Maybe, no, por ejemplo
si tienes dudas, siempre est√° bien evaluar las expresiones a mano
si no son muy grandes

Francisco Nebrera Perdomo

en eso tengo algunas dudas que ya te comentar√©
pero nada, te dejo seguir

Daniel D√≠az

ok
pues la notaci√≥n "do" lo que hace es transformar
"a <- m ; e"
en "m >>= \a -> e"
y "m ; n" en "m >> n"
uso ";" porque alinear en este chat es imposible

Francisco Nebrera Perdomo

sisi
eso se entendi√≥
estoy intentando comprender la conversi√≥n sint√°ctica

Daniel D√≠az

ok, transforma una cosa en la otra, como m√°quina
sin pensar
ejemplo!
x <- Id 3 ; return x
esto entrar√≠a en la primera regla

Francisco Nebrera Perdomo

ld 3 >>= \x -> return x

Daniel D√≠az

yesss
si quieres seguir, puedes incluso sustituir el >>= con lo que definimos antes
(\x -> return x) 3
=>
return 3
=>
Id 3

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

bien, pues as√≠ hace el compilador...
otro ejemplo
x <- Id 2 ; y <- Id 3 ; return x

Francisco Nebrera Perdomo

ld 2 >>= (\x -> ld 3 (\y -> return x))

Daniel D√≠az

claro
veo que esto te resulta f√°cil

Francisco Nebrera Perdomo

bueno
si hubiera un task manager en mi cerebro
cpu 101√ß%
xDDDDDDDDDDDDD

Daniel D√≠az

jajajaja
ok
pero espero que est√©s empezando a ver que no hay nada m√°gico en Monad, salvo una sintaxis que te ahorra escribir unos operadores y unas lambdas expl√≠citamente

Francisco Nebrera Perdomo

pues s√≠
vas a tener raz√≥n

Daniel D√≠az

el resultado de lo que has puesto ser√≠a Id 2

Francisco Nebrera Perdomo

lo que pasa es que no le termino de ver la utilidad :S
no me pegues con los pu√±os
xD

Daniel D√≠az

la m√≥nada Id no es √∫til pers√©
m√°s uqe para entender lo m√°s b√°sico
hacer una isntancia en un momento, y jugar con ella

Francisco Nebrera Perdomo

ok
pero vamos a ver
a la hora de evaluar el chorizo que me hiciste hacer

Daniel D√≠az

una clase siempre trata de poner en com√∫n unas funciones para muchos tipos a la vez

Francisco Nebrera Perdomo

es mejor que vaya paso a paso no?

Daniel D√≠az

s√≠, es mejor que vayas paso a paso
pero f√≠ajte en el resultado y en lo que empezaste...
x <- Id 2, y <- Id 3 ; return x
al final te ha devuelto Id 2
mmm, podr√≠amos interpretarlo como que el valor 2 fue a la x
el valor 3 a la y
y al final devolvimos el primero, la x

Francisco Nebrera Perdomo

s√≠
abstray√©ndonos s√≠
es decir un bind
solo guarda el contenido
en una variable no?
esa es mi duda, c√≥mo se qu√© se bindea?

Daniel D√≠az

¬øte refieres a "<-"?

Francisco Nebrera Perdomo

s√≠
joder es verdad
<-

Daniel D√≠az

s√≠, en general s√≠
si ves, en la sustituci√≥n de la sint√°xis
es el nombre de la variable de la expresi√≥n lambda que se va a usar en el "bind"
el cual, si lo que hay a la derecha de <- tiene tipo "m a"
el argumento de la funci√≥n a la derecha del bind tiene tipo "a"
as√≠ que, de alg√∫n modo, hemos "sacado" un valor de tipo "a" de uno de tipo "m a"
que ahora podemos usar en el resto de la expresi√≥n "do"
no s√© si soy claro

Francisco Nebrera Perdomo

sisi
desde luego
eso lo estudi√© en LYAH
que es un constructo que extrae valores de contextos mon√°dicos
y los deja libres

Daniel D√≠az

s√≠, aunque s√≥lo usable dentro del "do"

Francisco Nebrera Perdomo

debe ser pattern matching
lo que hace en realidad

Daniel D√≠az

y hay una norma
el √∫ltimo t√©rmino de una expresi√≥n "do" en la m√≥nada m
debe tener tipo "m a", para alg√∫n tipo a
aunque, esto lo fuerzan las √∫nicas dos normas gramaticales que tenemos
las dos acaban en un t√©rmino de esa forma

Francisco Nebrera Perdomo

ok
s√≠
te refieres a >>= y >> que devuelven las dos M b no?

Daniel D√≠az

me refiero a las nomras de sintaxis

Francisco Nebrera Perdomo

s√≠ ok

Daniel D√≠az

"a <- m ; e"
en "m >>= \a -> e"
y "m ; n" en "m >> n"
tanto en "a <- m ; e"
como en "m ; n"
"e" y "n" son cosas de tipo "m ?"
pongo ? para decir "algo" xD

Francisco Nebrera Perdomo

ok

Daniel D√≠az

as√≠ es, con esas dos √∫nicas reglas, no podemos terminar la expresi√≥n en algo de otro tipo
tiene que ser siempre "m ?"
ok... vamos a ir con Maybe... si te parece
¬ødudas hasta ahora?

Francisco Nebrera Perdomo

ninguna realmente
esto yo ma√±ana lo medito
con papel y boli y listo
puede seguir usted
xd

Daniel D√≠az

jaja medita, medita

Francisco Nebrera Perdomo

xDD

Daniel D√≠az

y escribe c√≥digo
ok, pues Maybe :: * -> *
as√≠ que sospechamos que a lo mejor podemos hacerlo instancia de Functor y Monad...
data Maybe a = Just a | Nothing
esta es la definici√≥n del tipo Maybe
es un tipo suma, pues puede tener valores de diferentes "formas"

Francisco Nebrera Perdomo

si
constructores de valor

Daniel D√≠az

Just 3 :: Maybe Int

Francisco Nebrera Perdomo

no?

Daniel D√≠az

s√≠
data constructors

Francisco Nebrera Perdomo

ok

Daniel D√≠az

tiene 2
Just y Nothing
Just :: a -> Maybe a
Nothing :: Maybe a

Francisco Nebrera Perdomo

s√≠
con esos he trabajado bastante

Daniel D√≠az

algo interesante es que Nothing habita muchos tipos...

Francisco Nebrera Perdomo

y los he metido en cases

Daniel D√≠az

Nothing :: Maybe Int
Nothing :: Maybe Bool
Nothing :: Maybe (Maybe Int)
en fin, la lista es infinita

Francisco Nebrera Perdomo

ok

Daniel D√≠az

curiosidades a parte, vamos a hacerlo instancia de Functor
en este caso
fmap :: (a -> b) -> Maybe a -> Maybe b
¬øc√≥mo definir√≠as una funci√≥n con ese tipo?

Francisco Nebrera Perdomo

ok
Nothing `fmap` _ = Nothing
no
mal
_ `fmap` Nothing = Nothing

Daniel D√≠az

curioso que lo escribas infijo 
pero s√≠, bien

Francisco Nebrera Perdomo

f `fmap` (Just x) = Just (f x)

Daniel D√≠az

s√≠, lo has hecho ya antes parece

Francisco Nebrera Perdomo

s√≠
ya te digo estas cosas me las estudi√©
y m√°s o menos me qued√© con la copla
xD

Daniel D√≠az

claro bien
pues te hago notar que te han hecho falta dos ecuaciones
porque tienes dos constructores
(o una ecuaci√≥n si usas case, pero bueno, dos pattern matchings en fin y al cabo)
esto pasa a menudo

Francisco Nebrera Perdomo

y eso siempre es as√≠?
o crece exponencialmente?
es decir, 3 constructores == 3 ecuaciones?
o tienes que mirar todas las posibles o hacer cosas extra√±as?

Daniel D√≠az

depende de la funci√≥n, aqu√≠ aparece s√≥lo 1 argumento
es decir, s√≥lo hay un Maybe que matchear
as√≠ que haces uno por constructor
si hubieran dos argumentos Maybe, te tocar√≠a hacer 4
pero claro, siempre se pueden reducir casos

Francisco Nebrera Perdomo

okok

Daniel D√≠az

pero, como mucho, ser√≠an 4

Francisco Nebrera Perdomo

guay

Daniel D√≠az

en fin
que fmap en el tipo Maybe, aplica la funci√≥n f a lo que tenga dentro
si es que tiene...

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

el Nothing lo deja tal cual
aunque 
lo cambia un poquito
le cambia el tipo!

Francisco Nebrera Perdomo

si
xD
lo deja inservible al pobre

Daniel D√≠az

lo pasa de Nothing :: Maybe a
a Nothing :: Maybe b
osea que en realidad no son el mismo Nothing

Francisco Nebrera Perdomo

joder pues es verdad
no hab√≠a ca√≠do

Daniel D√≠az

pues s√≠, es un detalle a tener en cuenta
ahora veamos si podemos hacer la instancia a Monad
de nuevo, empezamos con return
nuestras herramientas son
Just :: a -> Maybe a
Nothing :: Maybe a
y el pattern matching

Francisco Nebrera Perdomo

ok

Daniel D√≠az

return = ?

Francisco Nebrera Perdomo

un momento

Daniel D√≠az

k

Francisco Nebrera Perdomo

uf
me encuentro pescando

Daniel D√≠az

¬øpescando?

Francisco Nebrera Perdomo

si, aqui eso se dice
cuando no te enteras
xDDDDDDDDDDDd
dame 1 min a ver

Daniel D√≠az

recuerda que, en este caso, return :: a -> Maybe a

Francisco Nebrera Perdomo

yo te dir√≠a
return = Just

Daniel D√≠az

claro

Francisco Nebrera Perdomo

pero no se qu√© pasar√≠a con nothing

Daniel D√≠az

los tipos encajan, no? pues ya est√°
no hay ning√∫n argumento de tipo Maybe, no hay que hacer pattern matching

Francisco Nebrera Perdomo

joder es verdad
okok
menudo noob
xD

Daniel D√≠az

no te preocupes
conc√©ntrate en hacer encajar los tipos
con las cosas que tienes
lo dem√°s sale solo

Francisco Nebrera Perdomo

okok

Daniel D√≠az

vamos al >>=, que es el que da trabajo

Francisco Nebrera Perdomo

vale
a ver

Daniel D√≠az

te recuerdo la instancia
(>>= ) :: Maybe a -> (a -> Maybe b) -> Maybe b
tienes que hacer una funci√≥n con ese tipo

Francisco Nebrera Perdomo

s√≠
Nothing >>= f = Nothing

Daniel D√≠az

ok, eso me vale, no tengo a qu√© aplicar f, as√≠ que no te queda otro remedio que devolver Nothing
no hay opciones

Francisco Nebrera Perdomo

(Just x) >>= f = Just (f x)

Daniel D√≠az

calcula el tipo de la expresi√≥n a la derecha

Francisco Nebrera Perdomo

cierto
vuelvo a tropezar con la misma piedra
(Just x) >>= f = f x

Daniel D√≠az

s√≠
es igual que antes
s√≥lo hemos a√±adido el Nothing

Francisco Nebrera Perdomo

ok

Daniel D√≠az

pues ya tienes otra m√≥naa!
*m√≥nada

Francisco Nebrera Perdomo

pues s√≠
xD

Daniel D√≠az

esta es m√°s interesante...
si ves en la definici√≥n del bind para Nothing
no importa lo que haya a la derecha del bind, el resultado es Nothing

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

esto tendr√° sus consecuencias
vamos a ver un ejercicio
sabemos que 
en general
m >> k = m >>= \_ -> k
pero, ¬øc√≥mo funciona (>>) en el caso del tipo Maybe?
sustituye ese (>>= ) por el de la instancia Maybe para averiguarlo

Francisco Nebrera Perdomo

ok
pues no se
a ver
quedar√≠a

Daniel D√≠az

pista: case m of ...

Francisco Nebrera Perdomo

ok
case m of Nothing -> Nothing
case m of (Just x) -> Just (k x)
creo que est√° mal

Daniel D√≠az

el tipo no me encaja en absoluto
k :: m b, y lo est√°s aplicando a x
a ver, no te pido creatividad, es meramente evaluar con (>>= ) siendo el que hemos definido antes
a veces cuesta ser una m√°quina 

Francisco Nebrera Perdomo

ya te digo

Daniel D√≠az

pero es todo lo que necesitas ser en este caso

Francisco Nebrera Perdomo

otros lenguakes me entran f√°cil
pero este se resiste un poco
espera k pille editor de texto o algo
pa tener todo a mano

Daniel D√≠az

claro que s√≠
y aqu√≠: http://downloads.haskell.org/~ghc/latest/docs/html/libraries
si buscas "Prelude"
puedes consultar las definiciones todas las clases y tal

Francisco Nebrera Perdomo

case m of Nothing -> Nothing
Just x -> k

Daniel D√≠az

bien!
osea...
te simplifico algo
case m of Nothing -> Nothing ; _ -> k
s√≥lo para enfatizar cu√°n ignorado es el primer argumento en caso de que NO sea Nothing

Francisco Nebrera Perdomo

okok

Daniel D√≠az

entonces, ¬øqu√© hace (>>) para Maybe?
pues mira si el de la izquierda es Nothing, si lo es, devuelve Nothing, si no, devuelve el segundo argumento
es una l√≥gica diferente a la que presentaste al principio de (>>) devolver simplemente el segundo argumento

Francisco Nebrera Perdomo

s√≠
es m√°s condicional

Daniel D√≠az

digamos que depende de c√≥mo sea el primero...
en algo s√≠ que interviene

Francisco Nebrera Perdomo

okok

Daniel D√≠az

bueno, antes de que veamos algo divertido del tipo Maybe, vamos a hacer algo que estoy seguro ya has hecho
la funci√≥n "div" divide un "n√∫mero" entre otro
div 4 2  = 2
div 6 2 = 3

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

pero tiene un defecto...
div 8 0 = ERROR DESTRUCCION

Francisco Nebrera Perdomo

veo que no te gusta lo infijo
xD
jkasjkasjksajkas
s√≠

Daniel D√≠az

ok, el problema de div reside en su tipo
div :: Integral a => a -> a -> a
ignorando lo "Integral", que puede ser Int, Integer, etc
para el caso Int, por ejemplo
div :: Int -> Int -> Int
osea, que por su tipo, est√° obligado a tener como resultado un Int
de modo que se queda sin opciones para el caso "div 8 0: 

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

un tipo m√°s realista para "div" ser√≠a
div :: Int -> Int -> Maybe Int

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

estoy seguro de que has hecho esto

Francisco Nebrera Perdomo

pero eso te obliga a crearte un case

Daniel D√≠az

s√≠
pero te evita un CRASH EN TODA LA CARA

Francisco Nebrera Perdomo

xDDDDDDDDDDDDDD

Daniel D√≠az

que, en un programa de miles de l√≠neas
un "error divided by zero"
te tiras de los pelos

Francisco Nebrera Perdomo

xDDD
sisi

Daniel D√≠az

entonces, para evitar estos problemas
lo ideal es  que las funciones siempre puedan devolver algo
darles tipos m√°s realistas
como comentas, esto tiene un peso
pattern matching aqu√≠ y all√°
pero... ¬øy si escondemos ese pattern matching?
vamos a ver...
definamos
gooddiv _ 0 = Nothing
gooddiv n m = Just (div n m)
por supuesto, gooddiv :: Int -> Int -> Maybe Int

Francisco Nebrera Perdomo

ok

Daniel D√≠az

ahora estamos interesados en hacer un par de divisiones, y devolver la suma de los resultados si ambas divisiones han tenido √©xito...
con el antiguo div har√≠amos
myop a1 b1 a2 b2 = div a1 b1 + div a2 b2
ese es mi prop√≥sito... pero no quiero crashes...

Francisco Nebrera Perdomo

claro

Daniel D√≠az

as√≠ que voy a usar gooddiv
el problema es que no puedo usar (+) con el tipo Maybe de por medio
myop a1 b1 a2 b2 = gooddiv a1 b1 + gooddiv a2 b2
TYPE ERROR MALO

Francisco Nebrera Perdomo

s√≠
xD

Daniel D√≠az

habr√≠a que hacer pattern matching en los resultados...
case gooddiv a1 b1 of Nothing -> Nothing
Just c1 -> case a2 b2 of Nothing -> Nothing
Just c2 -> Just (c1 + c2)
...
no s√© si se ve bien en el chat lo que hice

Francisco Nebrera Perdomo

si

Daniel D√≠az

y me falta un "gooddiv"
sabr√°s donde

Francisco Nebrera Perdomo

de hecho en el tutorial
hacen algo muy parecido

Daniel D√≠az

claro, es muy est√°ndar esto
pero, muy rollo tanto "case", no?

Francisco Nebrera Perdomo

demasiado
xd

Daniel D√≠az

pero ah, uh, espera... Maybe es instancia de Monad... ¬øqu√© pasa si hago...?
do c1 <- gooddiv a1 b1 ; c2 <- gooddiv a2 b2 ; return (c1 + c2)
ejercicio: eval√∫a eso...

Francisco Nebrera Perdomo

ok
traducir√© pues

Daniel D√≠az

para que no sea muy lioso

Francisco Nebrera Perdomo

tengo que coger la chuleta

Daniel D√≠az

pon n√∫meros concretos

Francisco Nebrera Perdomo

xD

Daniel D√≠az

usa n√∫meros para a1,b1,a2,b2...
4,2,6,2, por ejemplo
y luego con
4,0,6,2

Francisco Nebrera Perdomo

gooddiv a1 b1 >>= (\c1 -> gooddiv a2 b2 >>= (\c2 -> return (c1 + c2)))

Daniel D√≠az

aha, ok, vamos con eso entonces
qu√© pasa con >>=
?
coge esa expresi√≥n, y simplemente mete la definici√≥n de (>>üòÉ para Maybe
(>>= )

Francisco Nebrera Perdomo

pues parece que
si pilla un Nothing no importa lo dem√°s
porque lo ir√° trasladando
no se si me explico
es decir
si alguno de los dos es Nothing
nunca se va a ejecutar ese return (c1+c2)

Daniel D√≠az

s√≠
realmente, si te pones a sustituir todo
te va a salir exactamente la definici√≥n que te he hecho antes
con los cases
magia!

Francisco Nebrera Perdomo

joder
pues todo empieza a cobrar sentido
es curioso

Daniel D√≠az

me alegro de que as√≠ sea

Francisco Nebrera Perdomo

xD

Daniel D√≠az

cuando tienes m√°s cosas, no s√≥lo dos divisiones
es genial, te ahorras mucho pattern matching
simplemente lo manejas como si todo funcionara
ese es el prop√≥sito de tener la instancia Monad para Maybe
haces todas las operaciones, devuelvan Nothing o no, y ya se encarga el bind de ir haciendo pattern match y descartando resultados devolviendo Nothing cuando sea oportuno

Francisco Nebrera Perdomo

es decir, el bind ese ahorra un mont√≥n de evaluaci√≥n si hay Nothings al principio

Daniel D√≠az

s√≠
descarta todo a partir del primer Nothing

Francisco Nebrera Perdomo

vale
pues est√° guapo
pero joder, tendr√© que acostumbrarme a usarlas
y ver cu√°ndo puedo usarlas tambi√©n

Daniel D√≠az

eso ya es experiencia
ya sabes para qu√© sirve Maybe

Francisco Nebrera Perdomo

si joder

Daniel D√≠az

y te he dado un caso de uso

Francisco Nebrera Perdomo

interesante

Daniel D√≠az

cuando haces varias operaciones que pueden "fallar"
y quieres usar sus resultados
es un momento perfecto para hacerl oas√≠

Francisco Nebrera Perdomo

okok, guay

Daniel D√≠az

por cierto, por a√±adir un detalle
si importas Control.Monad 
la funci√≥n liftM2
tiene tipo Monad m => (a -> b -> c) -> m a -> m b -> m c
es como fmap, pero con dos argumentos
¬øves?

Francisco Nebrera Perdomo

s√≠

Daniel D√≠az

bien
pues recordemos como definimos la funci√≥n de las divisiones al principio
myop a1 b1 a2 b2 = div a1 b1 + div a2 b2
esto es lo mismo que...
myop a1 b1 a2 b2 = (+) (div a1 b1) (div a2 b2)
haciendo el operador prefijo (ahora ver√°s por qu√©
)
¬øme sigues hasta ah√≠?

Francisco Nebrera Perdomo

claro

Daniel D√≠az

pues ahora defino
mygoodop a1 b1 a2 b2 = liftM2 (+) (gooddiv a1 b1) (gooddiv a2 b2)
y si miras los tipos, todo encaja
tenemos casi la misma funci√≥n, pero sin posibilidad de crash

Francisco Nebrera Perdomo

joder
es todo puro c√°lculo lambda
puras sustituciones aqu√≠ y all√°
y al final todo sale
xD

Daniel D√≠az

s√≠, Haskell es s√≥lo sustituir
es lo f√°cil y dif√≠cil que tiene
una vez te acostumbras a sustituir, ya lo tienes todo manejado

Francisco Nebrera Perdomo

no se, a m√≠ me dej√≥ loco en verdad

Daniel D√≠az

bueno, no todo, pero lo m√°s importante

Francisco Nebrera Perdomo

porque es incre√≠ble que hayan modos tan "raros" y a la vez tan bellos
xD
de hacer las cosas

Daniel D√≠az

y realmente, hemos escrito una funci√≥n que maneja posibilidad de fallos y tal en una s√≥lo l√≠nea
una vez que te manejas es pr√°ctica
*pr√°ctico

Francisco Nebrera Perdomo

sisi
al principio mi c√≥digo haskell eran churros
ahora ya uso composiciones
meto alg√∫n fmap
lambdas
foldr y demas
va siendo todo m√°s "de libro"
xD

Daniel D√≠az

entiendo

Francisco Nebrera Perdomo

tu como aprendiste todo?

Daniel D√≠az

lo primario me lo ense√±√≥ Jos√© Enrique Gallardo
luego ya me puse por mi cuenta, aunque si ten√≠a alguna duda acud√≠a a √©l
hasta que ya no me pod√≠a resolver m√°s dudas, entonces ya todo por mi cuenta

Francisco Nebrera Perdomo

es decir que t√∫ fuiste alumno de la universidad de malaga no?

Daniel D√≠az

s√≠

Francisco Nebrera Perdomo

okok
pues joder
all√≠ si que aprenden cosas wapas
aqu√≠ estan con el apestoso java

Daniel D√≠az

: (

Francisco Nebrera Perdomo

lo unico bueno que se da es C++

Daniel D√≠az

yo en realidad estudi√© Matem√°ticas

Francisco Nebrera Perdomo

eso lo explica todo xD
as√≠ te manejas con todo eso al momento
xD
entonces razonando con haskell
es m√°s para matem√°ticos que para ing. inform√°ticos no?

Daniel D√≠az

no
dan Haskell para los inform√°ticos tambi√©n
y usan ese libro

Francisco Nebrera Perdomo

okok
es que el libro tiene mucha demostraci√≥n e historias duras

Daniel D√≠az

claro, es que a sus autores les gusta eso

Francisco Nebrera Perdomo

esta increible todo eso
yo lo que pasa es que tengo lagunas en algunas partes

Daniel D√≠az

(a mi tambi√©n)

Francisco Nebrera Perdomo

pero eso na, eso es tiempo
s√≠ s√≠, a mi tambi√©n xD
todo eso mola
yo creo que todo va a ir por funcional
todo no

Daniel D√≠az

aaaah, creo que necesitas digerir un poco todo esto?

Francisco Nebrera Perdomo

no
lo que estoy cenando
xD
xq tengo que ir a la farmacia
a comprar medicamentos pa mi padre
xD
y ceno mientras chateo
multicore

Daniel D√≠az

entiendo

Francisco Nebrera Perdomo

me ibas a explicar mas no?

Daniel D√≠az

bueno, ver√°s
esto no tiene fin...

Francisco Nebrera Perdomo

eso ya lo veo
pero de calle adem√°s

Daniel D√≠az

y yo tambi√©n tengo cosas que hacer

Francisco Nebrera Perdomo

ah vale
joder
pues muchas gracias se√±or
si otra vez tienes un hueco

Daniel D√≠az

pero s√≠ es cierto que faltan cosas que a lo mejor te interesar√≠a que te explicara

Francisco Nebrera Perdomo

yo te contacto si tal
t√∫ me dices mas o menos cuando y listo
pa que no te sea tanta molestia

Daniel D√≠az

no es molestia
yo disfruto compartiendo lo que s√©

Francisco Nebrera Perdomo

xDDDD okok
pues guay
ya te digo muchas gracias

Daniel D√≠az

pero tengo responsabilidades que cumplir

Francisco Nebrera Perdomo

si que me aclaraste dudas

Daniel D√≠az

genial

Francisco Nebrera Perdomo

y nada otro d√≠a cuando los dos podamos pues hablaremos sobre esto

Daniel D√≠az

¬øalguna duda de todo esto antes de que me ponga a trabajar?

Francisco Nebrera Perdomo

trabajar√© bastante
no no, lo que me explicaste va fet√©n
eso es meditarlo como te dije

Daniel D√≠az

¬øfet√©n?

Francisco Nebrera Perdomo

l√°piz y papel
s√≠
es "castellano antiguo"
xD
ya no se usa ya
x
d

Daniel D√≠az

teclado y ghc?

Francisco Nebrera Perdomo

k va
yo prefiero papel
xD
aunque ghc y teclado est√°n muy bien

Daniel D√≠az

curioso
es un int√©rprete algo m√°s lento

Francisco Nebrera Perdomo

como mi cerebro
xDDDDDDDDDDD

Daniel D√≠az

jaja ok
pues voy al l√≠o

Francisco Nebrera Perdomo

okok
pues nada se√±or encantado y gracias
k vaya bien

Daniel D√≠az

el fin de semana lo paso en Madrid, pero la semana que viene ya vemos

Francisco Nebrera Perdomo

okok guay, venga

Daniel D√≠az

a partir del lunes me va bien
chao